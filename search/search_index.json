{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Q-ETL","text":"<p>A Python framework to create ETL processes powered bu the QGIS engine <sup>1</sup>.</p>"},{"location":"#basic-example","title":"Basic example","text":"<p>This is an example of how to load an input file, reproject the data to WGS84 (EPSG:4326) and write the output to a GeoJSON file.</p> <pre><code>reader = Input_Reader\nlayer = reader.geojson(\"testdata/kommuner.geojson\")\n\nworker = Worker\nreprojectedLayer = worker.reproject(layer, \"EPSG:4326\")\n\nwriter = Output_writer\nwriter.file(reprojectedLayer, \"C:/temp/kommuner_4326.geojson\", \"GeoJson\")\n</code></pre> <p>To run the job, simply call the .cmd file, and the job will execute. The translation log os placed in the log directory as specified in the configuration.</p> <p>See more in the Getting started section.</p>"},{"location":"#download","title":"Download","text":"<p>Download the latest release here.</p> <p><sup>1</sup> The Q-ETL project builds upon the work of the QGIS project (https://qgis.org). This project si not developed, endorsed by, or otherwise related to the QGIS project.</p>"},{"location":"Inputs/","title":"Inputs","text":"<p>The Input_Reader class is the base object to read different file formats</p>"},{"location":"Inputs/#python.engine.inputs.Input_Reader","title":"<code>Input_Reader</code>","text":"Source code in <code>python\\engine\\inputs.py</code> <pre><code>class Input_Reader:\n    logger = get_logger()\n\n    def wfs(uri):\n        \"\"\"\n        A function that reads a WFS service.\n\n        Parameters\n        ----------\n        uri : str\n            The uri can be a HTTP url to a WFS server (http://foobar/wfs?TYPENAME=xxx&amp;SRSNAME=yyy[&amp;FILTER=zzz) or a URI constructed using the QgsDataSourceURI class with the following parameters: - url=string (mandatory): HTTP url to a WFS server endpoint. e.g http://foobar/wfs - typename=string (mandatory): WFS typename - srsname=string (recommended): SRS like \u2018EPSG:XXXX\u2019 - username=string - password=string - authcfg=string - version=auto/1.0.0/1.1.0/2.0.0 -sql=string: full SELECT SQL statement with optional WHERE, ORDER BY and possibly with JOIN if supported on server - filter=string: QGIS expression or OGC/FES filter - restrictToRequestBBOX=1: to download only features in the view extent (or more generally in the bounding box of the feature iterator) - maxNumFeatures=number - IgnoreAxisOrientation=1: to ignore EPSG axis order for WFS 1.1 or 2.0 - InvertAxisOrientation=1: to invert axis order - hideDownloadProgressDialog=1: to hide the download progress dialog\n\n        Returns\n        -------\n        layer\n            A QgsVectorLayer object containing data from the WFS service.\n        \"\"\"\n\n        try:\n            logger.info(f'Reading WFS layer: {uri}')\n            layer = QgsVectorLayer(uri, \"WFS_Layer\" , 'WFS')\n            logger.info(\"Finished reading the WFS service\")\n            return layer\n        except Exception as error:\n            logger.error(f'An error occured reading the WFS {uri}')\n            logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n            logger.critical(\"Program terminated\")\n            script_failed()\n\n    def shapefile(filepath):\n        \"\"\"\n        A function that reads a shapefile\n\n        Parameters\n        ----------\n        filepath : str\n            The path to the shapefile to read\n\n        Returns\n        -------\n        layer\n            A QgsVectorLayer containing data from the shapefile.\n        \"\"\"\n        logger.info(f'Reading file: {filepath}')\n        try: \n            layer =  QgsVectorLayer(filepath, f'QgsLayer_ {str(randrange(1000))}', \"ogr\")\n            logger.info(\"Finished reading file\")\n            return layer\n        except Exception as error:\n            logger.error(f'An error occured opening file {filepath}')\n            logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n            logger.critical(\"Program terminated\")\n            script_failed()\n\n\n    def geojson(filepath):\n        \"\"\"\n        A function that reads a GeoJson file.\n\n        Parameters\n        ----------\n        filepath : str\n            The path to the GeoJson file to read\n\n        Returns\n        -------\n        layer\n            A QgsVectorLayer object containing data from the GeoJson file.\n        \"\"\"\n\n        logger.info(f'Reading file: {filepath}')\n        try:\n            layer =  QgsVectorLayer(filepath, f'QgsLayer_ {str(randrange(1000))}', \"ogr\")\n            logger.info(\"Finished reading file\")\n            return layer\n        except Exception as error:\n            logger.info(f'An error occured opening file {filepath}')\n            logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n            logger.critical(\"Program terminated\")\n            script_failed()\n\n    def fileBasedDB(file, layername, format):\n\n        if Path(file).exists() == False:\n            logger.error(f'{file} does not exist')\n            script_failed()\n\n        logger.info(f'Reading {format}: {file}')\n        try:\n            uri = f'{file}|layername={layername}'\n            layer = QgsVectorLayer(uri, f'QgsLayer_{str(randrange(1000))}', 'ogr')\n            logger.info(f'Finished reading {format}')\n            return layer\n        except Exception as error:\n            logger.info(f'An error occured opening {format}: {file}')\n            logger.error(type(error).__name__ + \" \u2013 \" + str(error))\n            logger.critical(\"Program terminated\")\n            script_failed()\n\n    def geopackage(file, layername):\n        \"\"\"\n        A function that reads alayer from a Geopackage file.\n\n        Parameters\n        ----------\n        file : str\n            The path to the geopackage file to read\n\n        Layername : str\n            The layer to load from the Geopackage\n\n        Returns\n        -------\n        layer\n            A QgsVectorLayer object containing data from the geopackage.\n        \"\"\"\n\n        layer = Input_Reader.fileBasedDB(file, layername, 'Geopackage')\n        return layer\n\n    def filegdb(file, layername):\n        \"\"\"\n        A function that read a layer from an ESRI File Geodatabase using the OpenFileGDB driver.\n\n        Parameters\n        ----------\n        file : str\n            The path to the file geodatabase to read.\n        layername : str\n            The layer to load from the database.\n        \"\"\"\n        layer = Input_Reader.fileBasedDB(file, layername, 'ESRI File Geodatabase')\n        return layer\n\n    def postGIS(connection, dbname, schema, table, geometryname='geom'):\n        \"\"\"        \n        A function that reads a layer from a PostGIS database\n\n        Args:\n            connection (string): connection name in settings\n            dbname (string): database name\n            schema (string): schema name\n            table (string): table name\n            geometryname (string,optional): name of geometry column. defaults to \"geom\"\n\n        Returns:\n            A QgsVectorLayer object containing data from the postgis database\n        \"\"\"\n        layer = Input_Reader.sqlDB('Postgres', connection, dbname, schema, table, geometryname)\n        return layer\n\n    def mssql(connection, dbname, schema, table, geometryname='Geometri'):\n        \"\"\"        \n        A function that reads a layer from a MSSQL database\n\n        Args:\n            connection (string): connection name in settings\n            dbname (string): database name\n            schema (string): schema name\n            table (string): table name\n            geometryname (string,optional): name of geometry column. defaults to \"geom\"\n\n        Returns:\n            A QgsVectorLayer object containing data from the postgis database\n        \"\"\"\n        layer = Input_Reader.sqlDB('MSSQL', connection, dbname, schema, table, geometryname)\n        return layer\n\n    def sqlDB(db_type, connection, dbname, schema, table, geometryname=\"geom\"):\n        \"\"\"        \n        A function that reads a layer from a SQL database\n\n        Args:\n            db_type (string): Type of SQL database. Postgres and MSSQL supported.\n            connection (string): connection name in settings\n            dbname (string): database name\n            schema (string): schema name\n            table (string): table name\n            geometryname (string,optional): name of geometry column. defaults to \"geom\"\n\n        Returns:\n            A QgsVectorLayer object containing data from the postgis database\n        \"\"\"\n\n        logger.info(f'Importing {schema}.{table} layer from {db_type}')\n\n        try:\n            config = get_config()\n            dbConnection = config['DatabaseConnections'][connection]\n            uri = QgsDataSourceUri()\n            logger.info(f'Reading from {db_type} database {dbname}, table {schema}.{table}')\n\n            uri.setConnection(dbConnection[\"host\"], dbConnection[\"port\"], dbname, dbConnection[\"user\"], dbConnection[\"password\"])\n            uri.setDataSource(schema, table, geometryname)\n\n            layer = QgsVectorLayer(uri.uri(False), \"layer\", f\"{db_type.lower()}\")\n\n            logger.info(f'Import from {db_type} completed')\n            if layerHasFeatures(layer):\n                logger.info(f'Imported {str(layer.featureCount())} features from {db_type}')\n            return layer    \n\n        except Exception as error:\n            logger.error(\"An error occured importing from {db_type}\")\n            logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n            logger.critical(\"Program terminated\")\n            script_failed()\n</code></pre>"},{"location":"Inputs/#python.engine.inputs.Input_Reader.filegdb","title":"<code>filegdb(file, layername)</code>","text":"<p>A function that read a layer from an ESRI File Geodatabase using the OpenFileGDB driver.</p>"},{"location":"Inputs/#python.engine.inputs.Input_Reader.filegdb--parameters","title":"Parameters","text":"<p>file : str     The path to the file geodatabase to read. layername : str     The layer to load from the database.</p> Source code in <code>python\\engine\\inputs.py</code> <pre><code>def filegdb(file, layername):\n    \"\"\"\n    A function that read a layer from an ESRI File Geodatabase using the OpenFileGDB driver.\n\n    Parameters\n    ----------\n    file : str\n        The path to the file geodatabase to read.\n    layername : str\n        The layer to load from the database.\n    \"\"\"\n    layer = Input_Reader.fileBasedDB(file, layername, 'ESRI File Geodatabase')\n    return layer\n</code></pre>"},{"location":"Inputs/#python.engine.inputs.Input_Reader.geojson","title":"<code>geojson(filepath)</code>","text":"<p>A function that reads a GeoJson file.</p>"},{"location":"Inputs/#python.engine.inputs.Input_Reader.geojson--parameters","title":"Parameters","text":"<p>filepath : str     The path to the GeoJson file to read</p>"},{"location":"Inputs/#python.engine.inputs.Input_Reader.geojson--returns","title":"Returns","text":"<p>layer     A QgsVectorLayer object containing data from the GeoJson file.</p> Source code in <code>python\\engine\\inputs.py</code> <pre><code>def geojson(filepath):\n    \"\"\"\n    A function that reads a GeoJson file.\n\n    Parameters\n    ----------\n    filepath : str\n        The path to the GeoJson file to read\n\n    Returns\n    -------\n    layer\n        A QgsVectorLayer object containing data from the GeoJson file.\n    \"\"\"\n\n    logger.info(f'Reading file: {filepath}')\n    try:\n        layer =  QgsVectorLayer(filepath, f'QgsLayer_ {str(randrange(1000))}', \"ogr\")\n        logger.info(\"Finished reading file\")\n        return layer\n    except Exception as error:\n        logger.info(f'An error occured opening file {filepath}')\n        logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n        logger.critical(\"Program terminated\")\n        script_failed()\n</code></pre>"},{"location":"Inputs/#python.engine.inputs.Input_Reader.geopackage","title":"<code>geopackage(file, layername)</code>","text":"<p>A function that reads alayer from a Geopackage file.</p>"},{"location":"Inputs/#python.engine.inputs.Input_Reader.geopackage--parameters","title":"Parameters","text":"<p>file : str     The path to the geopackage file to read</p> str <p>The layer to load from the Geopackage</p>"},{"location":"Inputs/#python.engine.inputs.Input_Reader.geopackage--returns","title":"Returns","text":"<p>layer     A QgsVectorLayer object containing data from the geopackage.</p> Source code in <code>python\\engine\\inputs.py</code> <pre><code>def geopackage(file, layername):\n    \"\"\"\n    A function that reads alayer from a Geopackage file.\n\n    Parameters\n    ----------\n    file : str\n        The path to the geopackage file to read\n\n    Layername : str\n        The layer to load from the Geopackage\n\n    Returns\n    -------\n    layer\n        A QgsVectorLayer object containing data from the geopackage.\n    \"\"\"\n\n    layer = Input_Reader.fileBasedDB(file, layername, 'Geopackage')\n    return layer\n</code></pre>"},{"location":"Inputs/#python.engine.inputs.Input_Reader.mssql","title":"<code>mssql(connection, dbname, schema, table, geometryname='Geometri')</code>","text":"<p>A function that reads a layer from a MSSQL database</p> <p>Parameters:</p> Name Type Description Default <code>connection</code> <code>string</code> <p>connection name in settings</p> required <code>dbname</code> <code>string</code> <p>database name</p> required <code>schema</code> <code>string</code> <p>schema name</p> required <code>table</code> <code>string</code> <p>table name</p> required <code>geometryname</code> <code>(string, optional)</code> <p>name of geometry column. defaults to \"geom\"</p> <code>'Geometri'</code> <p>Returns:</p> Type Description <p>A QgsVectorLayer object containing data from the postgis database</p> Source code in <code>python\\engine\\inputs.py</code> <pre><code>def mssql(connection, dbname, schema, table, geometryname='Geometri'):\n    \"\"\"        \n    A function that reads a layer from a MSSQL database\n\n    Args:\n        connection (string): connection name in settings\n        dbname (string): database name\n        schema (string): schema name\n        table (string): table name\n        geometryname (string,optional): name of geometry column. defaults to \"geom\"\n\n    Returns:\n        A QgsVectorLayer object containing data from the postgis database\n    \"\"\"\n    layer = Input_Reader.sqlDB('MSSQL', connection, dbname, schema, table, geometryname)\n    return layer\n</code></pre>"},{"location":"Inputs/#python.engine.inputs.Input_Reader.postGIS","title":"<code>postGIS(connection, dbname, schema, table, geometryname='geom')</code>","text":"<p>A function that reads a layer from a PostGIS database</p> <p>Parameters:</p> Name Type Description Default <code>connection</code> <code>string</code> <p>connection name in settings</p> required <code>dbname</code> <code>string</code> <p>database name</p> required <code>schema</code> <code>string</code> <p>schema name</p> required <code>table</code> <code>string</code> <p>table name</p> required <code>geometryname</code> <code>(string, optional)</code> <p>name of geometry column. defaults to \"geom\"</p> <code>'geom'</code> <p>Returns:</p> Type Description <p>A QgsVectorLayer object containing data from the postgis database</p> Source code in <code>python\\engine\\inputs.py</code> <pre><code>def postGIS(connection, dbname, schema, table, geometryname='geom'):\n    \"\"\"        \n    A function that reads a layer from a PostGIS database\n\n    Args:\n        connection (string): connection name in settings\n        dbname (string): database name\n        schema (string): schema name\n        table (string): table name\n        geometryname (string,optional): name of geometry column. defaults to \"geom\"\n\n    Returns:\n        A QgsVectorLayer object containing data from the postgis database\n    \"\"\"\n    layer = Input_Reader.sqlDB('Postgres', connection, dbname, schema, table, geometryname)\n    return layer\n</code></pre>"},{"location":"Inputs/#python.engine.inputs.Input_Reader.shapefile","title":"<code>shapefile(filepath)</code>","text":"<p>A function that reads a shapefile</p>"},{"location":"Inputs/#python.engine.inputs.Input_Reader.shapefile--parameters","title":"Parameters","text":"<p>filepath : str     The path to the shapefile to read</p>"},{"location":"Inputs/#python.engine.inputs.Input_Reader.shapefile--returns","title":"Returns","text":"<p>layer     A QgsVectorLayer containing data from the shapefile.</p> Source code in <code>python\\engine\\inputs.py</code> <pre><code>def shapefile(filepath):\n    \"\"\"\n    A function that reads a shapefile\n\n    Parameters\n    ----------\n    filepath : str\n        The path to the shapefile to read\n\n    Returns\n    -------\n    layer\n        A QgsVectorLayer containing data from the shapefile.\n    \"\"\"\n    logger.info(f'Reading file: {filepath}')\n    try: \n        layer =  QgsVectorLayer(filepath, f'QgsLayer_ {str(randrange(1000))}', \"ogr\")\n        logger.info(\"Finished reading file\")\n        return layer\n    except Exception as error:\n        logger.error(f'An error occured opening file {filepath}')\n        logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n        logger.critical(\"Program terminated\")\n        script_failed()\n</code></pre>"},{"location":"Inputs/#python.engine.inputs.Input_Reader.sqlDB","title":"<code>sqlDB(db_type, connection, dbname, schema, table, geometryname='geom')</code>","text":"<p>A function that reads a layer from a SQL database</p> <p>Parameters:</p> Name Type Description Default <code>db_type</code> <code>string</code> <p>Type of SQL database. Postgres and MSSQL supported.</p> required <code>connection</code> <code>string</code> <p>connection name in settings</p> required <code>dbname</code> <code>string</code> <p>database name</p> required <code>schema</code> <code>string</code> <p>schema name</p> required <code>table</code> <code>string</code> <p>table name</p> required <code>geometryname</code> <code>(string, optional)</code> <p>name of geometry column. defaults to \"geom\"</p> <code>'geom'</code> <p>Returns:</p> Type Description <p>A QgsVectorLayer object containing data from the postgis database</p> Source code in <code>python\\engine\\inputs.py</code> <pre><code>def sqlDB(db_type, connection, dbname, schema, table, geometryname=\"geom\"):\n    \"\"\"        \n    A function that reads a layer from a SQL database\n\n    Args:\n        db_type (string): Type of SQL database. Postgres and MSSQL supported.\n        connection (string): connection name in settings\n        dbname (string): database name\n        schema (string): schema name\n        table (string): table name\n        geometryname (string,optional): name of geometry column. defaults to \"geom\"\n\n    Returns:\n        A QgsVectorLayer object containing data from the postgis database\n    \"\"\"\n\n    logger.info(f'Importing {schema}.{table} layer from {db_type}')\n\n    try:\n        config = get_config()\n        dbConnection = config['DatabaseConnections'][connection]\n        uri = QgsDataSourceUri()\n        logger.info(f'Reading from {db_type} database {dbname}, table {schema}.{table}')\n\n        uri.setConnection(dbConnection[\"host\"], dbConnection[\"port\"], dbname, dbConnection[\"user\"], dbConnection[\"password\"])\n        uri.setDataSource(schema, table, geometryname)\n\n        layer = QgsVectorLayer(uri.uri(False), \"layer\", f\"{db_type.lower()}\")\n\n        logger.info(f'Import from {db_type} completed')\n        if layerHasFeatures(layer):\n            logger.info(f'Imported {str(layer.featureCount())} features from {db_type}')\n        return layer    \n\n    except Exception as error:\n        logger.error(\"An error occured importing from {db_type}\")\n        logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n        logger.critical(\"Program terminated\")\n        script_failed()\n</code></pre>"},{"location":"Inputs/#python.engine.inputs.Input_Reader.wfs","title":"<code>wfs(uri)</code>","text":"<p>A function that reads a WFS service.</p>"},{"location":"Inputs/#python.engine.inputs.Input_Reader.wfs--parameters","title":"Parameters","text":"<p>uri : str     The uri can be a HTTP url to a WFS server (http://foobar/wfs?TYPENAME=xxx&amp;SRSNAME=yyy[&amp;FILTER=zzz) or a URI constructed using the QgsDataSourceURI class with the following parameters: - url=string (mandatory): HTTP url to a WFS server endpoint. e.g http://foobar/wfs - typename=string (mandatory): WFS typename - srsname=string (recommended): SRS like \u2018EPSG:XXXX\u2019 - username=string - password=string - authcfg=string - version=auto/1.0.0/1.1.0/2.0.0 -sql=string: full SELECT SQL statement with optional WHERE, ORDER BY and possibly with JOIN if supported on server - filter=string: QGIS expression or OGC/FES filter - restrictToRequestBBOX=1: to download only features in the view extent (or more generally in the bounding box of the feature iterator) - maxNumFeatures=number - IgnoreAxisOrientation=1: to ignore EPSG axis order for WFS 1.1 or 2.0 - InvertAxisOrientation=1: to invert axis order - hideDownloadProgressDialog=1: to hide the download progress dialog</p>"},{"location":"Inputs/#python.engine.inputs.Input_Reader.wfs--returns","title":"Returns","text":"<p>layer     A QgsVectorLayer object containing data from the WFS service.</p> Source code in <code>python\\engine\\inputs.py</code> <pre><code>def wfs(uri):\n    \"\"\"\n    A function that reads a WFS service.\n\n    Parameters\n    ----------\n    uri : str\n        The uri can be a HTTP url to a WFS server (http://foobar/wfs?TYPENAME=xxx&amp;SRSNAME=yyy[&amp;FILTER=zzz) or a URI constructed using the QgsDataSourceURI class with the following parameters: - url=string (mandatory): HTTP url to a WFS server endpoint. e.g http://foobar/wfs - typename=string (mandatory): WFS typename - srsname=string (recommended): SRS like \u2018EPSG:XXXX\u2019 - username=string - password=string - authcfg=string - version=auto/1.0.0/1.1.0/2.0.0 -sql=string: full SELECT SQL statement with optional WHERE, ORDER BY and possibly with JOIN if supported on server - filter=string: QGIS expression or OGC/FES filter - restrictToRequestBBOX=1: to download only features in the view extent (or more generally in the bounding box of the feature iterator) - maxNumFeatures=number - IgnoreAxisOrientation=1: to ignore EPSG axis order for WFS 1.1 or 2.0 - InvertAxisOrientation=1: to invert axis order - hideDownloadProgressDialog=1: to hide the download progress dialog\n\n    Returns\n    -------\n    layer\n        A QgsVectorLayer object containing data from the WFS service.\n    \"\"\"\n\n    try:\n        logger.info(f'Reading WFS layer: {uri}')\n        layer = QgsVectorLayer(uri, \"WFS_Layer\" , 'WFS')\n        logger.info(\"Finished reading the WFS service\")\n        return layer\n    except Exception as error:\n        logger.error(f'An error occured reading the WFS {uri}')\n        logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n        logger.critical(\"Program terminated\")\n        script_failed()\n</code></pre>"},{"location":"constructors/","title":"Constructors","text":""},{"location":"constructors/#python.engine.constructors.Constructor","title":"<code>Constructor</code>","text":"Source code in <code>python\\engine\\constructors.py</code> <pre><code>class Constructor:\n\n    logger = get_logger()\n\n    def layerFromWKT(type: QgsVectorLayer, wktList: list, epsg: int):\n        \"\"\"\n        Create a layer from a list of wkt's.\n\n        Parameters\n        ----------\n        type : String\n            One of 'Point', 'Line','Polygon','MultiPoint', 'MultiLine', 'MultiPolygon'\n\n        wktList : List\n            List of wkt's to be added to the new layer\n\n        epsg : integer\n            The epsg code corrosponding to the wkt features coordinate system.\n\n        Returns\n        -------\n        QgsVectorLayer\n            The output layers containing the wkt's\n        \"\"\"\n\n        logger.info(\"Creating layer from WKT\")\n        logger.info(f'Number of features {str(len(wktList))}, type: {type}')\n\n        if type in ['Point', 'Line','Polygon','MultiPoint', 'MultiLine', 'MultiPolygon']:\n\n            try:\n                wkt_layer = QgsVectorLayer(f'{type}?crs=epsg:{str(epsg)}', \"WKT_Layer\", \"Memory\")\n\n                features = []\n                for elm in wktList:\n                    feature = QgsFeature()\n                    geom = QgsGeometry.fromWkt(elm)\n                    feature.setGeometry(geom)\n                    features.append(feature)\n                wkt_layer.dataProvider().addFeatures(features)\n                wkt_layer.updateFields()\n                wkt_layer.commitChanges()\n\n                logger.info(\"layerFromWKT finished\")\n                if layerHasFeatures(wkt_layer):\n                    logger.info(f'Returning {str(wkt_layer.featureCount())} features')\n                return wkt_layer\n\n            except Exception as error:\n                logger.error(\"An error occured in crating WKT layer\")\n                logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n                logger.critical(\"Program terminated\" )\n                sys.exit()\n        else:\n                logger.error(\"An error occured in crating WKT layer\")\n                logger.error('Unsupported type, use Point/Line/Polygon/multiPoint/MultiLine/Multipolygon' )\n                logger.critical(\"Program terminated\" )\n                sys.exit()\n\n    def bboxFromLayer(layer: str):\n        \"\"\"_summary_\n\n        Parameters\n        ----------\n        layer : QgsVectorLayer\n            The layer, that the bbox is calculated uppon.\n\n        Returns\n        -------\n        QgsVectorLayer\n            The output layer, containing the bbox from the input layer\n\n        \"\"\"\n        logger.info(\"Extracting bbox from layer\" )\n        if layerHasFeatures(layer):\n            logger.info(f'Processing {str(layer.featureCount())} features')\n        try:\n            ext = layer.extent()\n            xmin = ext.xMinimum()\n            xmax = ext.xMaximum()\n            ymin = ext.yMinimum()\n            ymax = ext.yMaximum()\n            epsg = layer.crs().authid()\n            data = [xmin, ymin, xmax, ymax, epsg]\n            logger.info(\"Extract bbox finished\")\n            return data\n        except Exception as error:\n            logger.error(\"An error occured extracting bbox\")\n            logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n            logger.critical(\"Program terminated\" )\n            sys.exit()\n</code></pre>"},{"location":"constructors/#python.engine.constructors.Constructor.bboxFromLayer","title":"<code>bboxFromLayer(layer)</code>","text":"<p>summary</p>"},{"location":"constructors/#python.engine.constructors.Constructor.bboxFromLayer--parameters","title":"Parameters","text":"<p>layer : QgsVectorLayer     The layer, that the bbox is calculated uppon.</p>"},{"location":"constructors/#python.engine.constructors.Constructor.bboxFromLayer--returns","title":"Returns","text":"<p>QgsVectorLayer     The output layer, containing the bbox from the input layer</p> Source code in <code>python\\engine\\constructors.py</code> <pre><code>def bboxFromLayer(layer: str):\n    \"\"\"_summary_\n\n    Parameters\n    ----------\n    layer : QgsVectorLayer\n        The layer, that the bbox is calculated uppon.\n\n    Returns\n    -------\n    QgsVectorLayer\n        The output layer, containing the bbox from the input layer\n\n    \"\"\"\n    logger.info(\"Extracting bbox from layer\" )\n    if layerHasFeatures(layer):\n        logger.info(f'Processing {str(layer.featureCount())} features')\n    try:\n        ext = layer.extent()\n        xmin = ext.xMinimum()\n        xmax = ext.xMaximum()\n        ymin = ext.yMinimum()\n        ymax = ext.yMaximum()\n        epsg = layer.crs().authid()\n        data = [xmin, ymin, xmax, ymax, epsg]\n        logger.info(\"Extract bbox finished\")\n        return data\n    except Exception as error:\n        logger.error(\"An error occured extracting bbox\")\n        logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n        logger.critical(\"Program terminated\" )\n        sys.exit()\n</code></pre>"},{"location":"constructors/#python.engine.constructors.Constructor.layerFromWKT","title":"<code>layerFromWKT(type, wktList, epsg)</code>","text":"<p>Create a layer from a list of wkt's.</p>"},{"location":"constructors/#python.engine.constructors.Constructor.layerFromWKT--parameters","title":"Parameters","text":"<p>type : String     One of 'Point', 'Line','Polygon','MultiPoint', 'MultiLine', 'MultiPolygon'</p> List <p>List of wkt's to be added to the new layer</p> integer <p>The epsg code corrosponding to the wkt features coordinate system.</p>"},{"location":"constructors/#python.engine.constructors.Constructor.layerFromWKT--returns","title":"Returns","text":"<p>QgsVectorLayer     The output layers containing the wkt's</p> Source code in <code>python\\engine\\constructors.py</code> <pre><code>def layerFromWKT(type: QgsVectorLayer, wktList: list, epsg: int):\n    \"\"\"\n    Create a layer from a list of wkt's.\n\n    Parameters\n    ----------\n    type : String\n        One of 'Point', 'Line','Polygon','MultiPoint', 'MultiLine', 'MultiPolygon'\n\n    wktList : List\n        List of wkt's to be added to the new layer\n\n    epsg : integer\n        The epsg code corrosponding to the wkt features coordinate system.\n\n    Returns\n    -------\n    QgsVectorLayer\n        The output layers containing the wkt's\n    \"\"\"\n\n    logger.info(\"Creating layer from WKT\")\n    logger.info(f'Number of features {str(len(wktList))}, type: {type}')\n\n    if type in ['Point', 'Line','Polygon','MultiPoint', 'MultiLine', 'MultiPolygon']:\n\n        try:\n            wkt_layer = QgsVectorLayer(f'{type}?crs=epsg:{str(epsg)}', \"WKT_Layer\", \"Memory\")\n\n            features = []\n            for elm in wktList:\n                feature = QgsFeature()\n                geom = QgsGeometry.fromWkt(elm)\n                feature.setGeometry(geom)\n                features.append(feature)\n            wkt_layer.dataProvider().addFeatures(features)\n            wkt_layer.updateFields()\n            wkt_layer.commitChanges()\n\n            logger.info(\"layerFromWKT finished\")\n            if layerHasFeatures(wkt_layer):\n                logger.info(f'Returning {str(wkt_layer.featureCount())} features')\n            return wkt_layer\n\n        except Exception as error:\n            logger.error(\"An error occured in crating WKT layer\")\n            logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n            logger.critical(\"Program terminated\" )\n            sys.exit()\n    else:\n            logger.error(\"An error occured in crating WKT layer\")\n            logger.error('Unsupported type, use Point/Line/Polygon/multiPoint/MultiLine/Multipolygon' )\n            logger.critical(\"Program terminated\" )\n            sys.exit()\n</code></pre>"},{"location":"getting_started/","title":"Getting started","text":"<p>This guide will show you how to set up and configure QGIS ETL to run jobs. At the end, the system will be configured to run a simple job, performing an ETL task - loading, manipulating, and writing data.</p>"},{"location":"getting_started/#setup","title":"Setup","text":""},{"location":"getting_started/#step-1-unzip","title":"Step 1 - Unzip","text":"<p>Fetch latest relase here. This will download a zip file containing the application. Unzip this archive. </p> <p>This example will unzip the application in C:/Apps</p> <p>When it is unzipped, you will have a folder like this: </p> <p>TODO: ADD FOLDER STRUCTURE EXAMPLE</p>"},{"location":"getting_started/#step-2-settingsjson","title":"Step 2 - settings.json","text":"<p>The first step we need to do is to go through the process of creating the settings.json file in the root. Make a copy of the file settings_template.json, and rename it to settings.json. </p> <p>TODO: ADD EXPLANATION OF SETTINGS.JSON</p>"},{"location":"getting_started/#step-3-the-python-project-file","title":"Step 3 - The python project file.","text":"<p>Navigate to the python folder and locate the boilerplate.py file. Make a copy of this file and rename it to MyProject.py.</p> <p>Open and examine the content of the file - there is not much in it yet:</p> <pre><code>from core import *\nfrom engine import *\n\n## Code goes here\n</code></pre> <p>Let's keep the file open, we will use it in a short while, we just have one more file to modify before we can start to code the ETL job.</p>"},{"location":"getting_started/#step-4-the-project-cmd-file","title":"Step 4 - The project cmd file.","text":"<p>Go to the root folder of the application, and locate the file boilerplate.cmd. Make a copy of this file, and rename it to MyProject.cmd.</p> <p>Open this new .cmd file:</p> <pre><code>&lt;PATH-TO&gt;\\python-qgis.bat &lt;FULL-PATH-TO-PYTHON-SCRIPT&gt;\n</code></pre> <p>You need to insert the full path to the python-qgis.bat and the full path to MyProject.py file we created in the previous step. Depending on how you have made your QGIS installation, the path to python-qgis.bat is different. In a OSGEO4W installation, it is in the OSGEO4W\\bin folder. In a standalone QGIS installation, it is in QGIS\\bin. The path to the MyProject.py depends on where you have placed your project.</p> <p>An example cmd file could look like this:</p> <pre><code>C:\\App\\OSGeo4W\\bin\\python-qgis.bat C:\\App\\Q-ETL\\python\\MyProject.py\n</code></pre> <p>Now, the project is configured to run the project file MyProject.py - and we will now turn our focus on developing our ETL model</p>"},{"location":"getting_started/#development","title":"Development","text":"<p>For this tutorial, we will load data from a WFS service, reproject it, and store it on disk in a Geopackage. The WFS service that we are going to use, contains bus routes and stops - and we are interested in getting the bus stops out. The service comes in EPSG:25832.</p> <p>The service:</p> <pre><code>https://geofyn.admin.gc2.io/wfs/geofyn/fynbus/25832?\n</code></pre> <p>The typename we are looking for is Fynbus:stops</p> <p>For it to work in our code, we need to turn it into a QGIS URI string. the simplest way to do that is to let QGIS load the layer for you and extract the information. When the layer is loaded, go to the properties of the layer, and select 'Information'- here the URI string can be copied:</p> <p>TODO: ADD SCREENSHOT FROM QGIS</p> <p>The string we are going to use as URI is:</p> <pre><code>\"srsname='EPSG:25832' typename='fynbus:stops' url='https://geofyn.admin.gc2.io/wfs/geofyn/fynbus/25832'\"\n</code></pre> <p>Now, it is time to go to our project and start to code the operations. </p> <p>We can try and run the code as it is, verify that all configurations are correct, and see how that program executes. Go to the root folder of your project, and run the MyProject.cmd file. This will open a terminal window, which reports the execution progress. When it finishes, go to the folder that was specified as LogPath in the config, and locate the new log file from this run. It has the project name and timestamp in the filename.</p> <p>This is the basic format of the log file generated on each run. It validates the configuration, examines the environment and operating system, and finally, it starts to execute the script - which in this case is empty. Now we have confirmed that the boilerplates and configuration of our project are valid, and we can build the code to manage the data.</p> <p>The process has three steps: Load, reproject and write.</p> <ol> <li>Load data The code is structured in classes - the three main ones are going to be used her. First we create a reader, by invoking the Input_Reader class: Then, we construct our input layer, by calling the 'wfs' method on our reader. By calling this method, we are going to give it just one parameter - the URI that we constructed in QGIS. we assign the output layer to a variable, in this case we call it wfslayer, for easy readability of this example. </li> </ol> <pre><code>reader = Input_Reader\nwfslayer = reader.wfs(\"srsname='EPSG:25832' typename='fynbus:stops' url='https://geofyn.admin.gc2.io/wfs/geofyn/fynbus/25832'\")\n</code></pre> <ol> <li>Next, we must do the reprojection of the data from EPSG:25832 to EPSG:4326. for this, we will create a worker, which will be able to perform operations on layers. This is based on the Worker class. QGIS knows the ESPSG code of the layer, so all we need to specify is the target code (we omit the 'EPSG:', so it is only an input integer here...)</li> </ol> <pre><code>worker = Worker\nreprojectedlayer = worker.reproject(wfslayer, 4326)\n</code></pre> <ol> <li>Finally, we will write our reprojected layer to a Geopackage file. For this, we will use our Output_writer class. On the writer, we will call the 'geopackage' method, which takes four arguments: Layer to write, layername in the geopackage, the geopackage file to write to, and an option to overwrite the Geopackage.</li> </ol> <pre><code>writer = Output_Writer\nwriter.geopackage(reprojectedlayer,'Busstops','c:/temp/fynbus.gpkg',True)\n</code></pre> <p>Now, the code looks like this:</p> <p>TODO: INSERT EXAMPLE</p> <p>Now, let's call our MyProject.cmd file, and wait for it to finish. It won't take long, the QGIS engine is super fast. When the job finishes, let go and inspect the log file that is created. The start parts are the same as all other runs, but the script part at the bottom is now different:</p> <p>As the log states, it reads a total of 4706 features from the source with the wfs reader. it channels these features through the reprojector worker - also returning the same 4706 features (which indicates no geometry problems). Finally, it writes the features to the Geopackage, and the job ends with success \u2764\ufe0f </p> <p>This concludes this quickstart tutorial. The next step is to browse the API documentation to find out which methods are available in Input_reader, Worker, and Output_Writer classes. </p> <p>On behalf of the QGIS ETL team, Enjoy \ud83d\ude03 </p>"},{"location":"outputs/","title":"Outputs","text":"<p>The Output_writer class is the base class for writing to different dataformats.</p>"},{"location":"outputs/#python.engine.outputs.Output_Writer","title":"<code>Output_Writer</code>","text":"Source code in <code>python\\engine\\outputs.py</code> <pre><code>class Output_Writer:\n\n    logger = get_logger()\n\n    def excel(layer: QgsVectorLayer, path : str):\n        \"\"\"\n        A function that exports a QgsVectorLayer into an excel spredsheet.\n\n        Parameters\n        ----------\n        layer : QgsVectorLayer\n            The QgsVectorLayer to be exported into an excel spredsheet.\n\n        path : str\n            the ouput file to be created.\n\n        \"\"\"\n\n        if layerHasFeatures(layer):\n            logger.info(f'Writing {str(layer.featureCount())} features to Excel : {path}')\n        try:\n            parameter = {'LAYERS': [layer],\n                    'USE_ALIAS': True,\n                    'FORMATTED_VALUES': False,\n                    'OUTPUT': path}\n            processing.run(\"native:exporttospreadsheet\", parameter)\n            logger.info(f'Parameters: {str(parameter)}')\n            logger.info(\"Export to Excel completed\")\n        except Exception as error:\n            logger.error(\"An error occured exporting layer to Excel\")\n            logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n            logger.critical(\"Program terminated\")\n            script_failed()\n\n\n    def postgis(layer: QgsVectorLayer, connection : str, dbname: str, schema: str, tablename: str, overwrite: bool = True):\n        \"\"\"\n        A function that exports a QgsVectorLayer into a Postgis database.\n\n        Parameters\n        ----------\n        layer : QgsVectorLayer\n            The QgsVectorLayer to be exported into Postgis\n\n        connection : str\n            The name of the connection object in the settings file\n\n        dbname : str\n            The database name\n\n        schema : str\n            Schema name\n\n        tablename : str\n            The name of the table that will be imported\n\n        overwrite : bool\n            Defaults to True. Should the resulting table in Postgis be overwritten if it exists. If set to False, then it will append the data.\n        \"\"\"\n\n        if layerHasFeatures(layer):\n            logger.info(f'Exporting {str(layer.featureCount())} features to Postgis')\n        tempfile = create_tempfile(layer, 'postgis')\n        logger.info('Temporary layer created')\n\n        try:\n            config = get_config()\n            dbConnection = config['DatabaseConnections'][connection]\n\n            # ogr2ogr parameters\n            table = f'-nln \"{schema}.{tablename}\"'\n            ogrconnection = f'PG:\"host={dbConnection[\"host\"]} port={dbConnection[\"port\"]} dbname={dbname} schemas={schema} user={dbConnection[\"user\"]} password={dbConnection[\"password\"]}\"'\n            ogr2ogrstring = f'{config[\"QGIS_bin_folder\"]}/ogr2ogr.exe -f \"PostgreSQL\" {ogrconnection} {tempfile} {table}'\n            if overwrite:\n                ogr2ogrstring = f'{ogr2ogrstring} -overwrite'\n            logger.info(f'Writing to PostGIS database {dbname}')\n            run = subprocess.run(ogr2ogrstring, capture_output=True)\n            delete_tempfile(tempfile)\n            logger.info('Temporary layer removed')\n            logger.info('Export to PostGIS completed')\n\n        except Exception as error:\n            logger.error(\"An error occured exporting to Postgis\")\n            logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n            logger.critical(\"Program terminated\")\n            script_failed()\n\n    def geopackage(layer: QgsVectorLayer, layername: str, geopackage: str, overwrite: bool):\n        \"\"\"\n        A function that writes a QgsVectorLayer to a Geopackage file. \n\n        Parameters\n        ----------\n        layer : QgsVectorLayer\n            The QgsVectorLayer that is to be written to the geopackage\n\n        layername : String\n            The name of the layer in the geopackage file\n\n        geopackage : String\n            The full path for the geopackage to be created\n\n        overwrite : Boolean\n\n            Specify wheather the writer will overwrite existing geopackage or append layer. Boolean True/False\n\n        \"\"\"\n\n        if layerHasFeatures(layer):\n            logger.info(f'Writing {str(layer.featureCount())} features to geopackage : {geopackage}')\n        try:\n            layer.setName(layername)\n            parameter = {'LAYERS': [layer],\n                    'OUTPUT': geopackage,\n                    'OVERWRITE': overwrite,\n                    'SAVE_STYLES': False,\n                    'SAVE_METADATA': False,\n                    'SELECTED_FEATURES_ONLY': False}\n            processing.run(\"native:package\", parameter)\n            logger.info(f'Parameters: {str(parameter)}')\n            logger.info(\"Export to Geopackage completed\")\n        except Exception as error:\n            logger.error(\"An error occured exporting layer to geopackage\")\n            logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n            logger.critical(\"Program terminated\")\n            script_failed()\n\n    def append_geopackage(layer: str, layername: str, geopackage: str):\n        \"\"\"\n        Append a layer to an existing geopackage.\n        If the new layer does not exist, it will be created. It it exists, the features will be appended to the layer.\n\n        Parameters\n        ----------\n        layer : QgsVectorLayer\n            The QgsVectorLayer that is to be written to a file\n\n        layername : String\n            The name of the layer in the geopackage file\n\n        geopackage : String\n            The full path for the geopackage to be created\n\n        \"\"\"\n        logger.info(\"Running append layer to Geopackage\")\n        if os.path.isfile(geopackage):\n            logger.info(f'Geopackage {geopackage} exists, appending layer')\n            tempfile = create_tempfile(layer, 'append_geopackage')\n\n            try:\n                config = get_config()\n                ## ogr2ogr parameters\n                table = f'-nln \"{layername}\"'\n                ogr2ogrstring = f'{config[\"QGIS_bin_folder\"]}/ogr2ogr.exe -f \"GPKG\" {geopackage} {tempfile} -nln {layername} -update -append'\n                logger.info(f'Writing new layer {layername} to: {geopackage}')\n                logger.info(f'Ogr2ogr command {ogr2ogrstring}')\n                ogr2ogrstring.join(' -progress')\n                run = subprocess.run(ogr2ogrstring, stderr=subprocess.STDOUT)\n                if run.stdout:\n                    logger.info(run.stdout)\n                delete_tempfile(tempfile)\n                logger.info(f'Append to geopackage completed')\n\n            except Exception as error:\n                logger.error(\"An error occured appending layer to geopackage\")\n                logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n                logger.critical(\"Program terminated\")\n                script_failed() \n        else:\n            logger.error(\"Target geopackage not found\")\n            logger.critical(\"Program terminated\")\n            script_failed()     \n\n    def file(layer: str, path: str, format: str):\n        \"\"\"\n        Parameters\n        ----------\n        layer : QgsVectorLayer\n            The QgsVectorLayer that is to be written to a file\n\n        path : _type_\n            The full path for the file to be created\n\n        format : _type_\n            The driver type used to write the data to the file. \n        \"\"\"\n\n        if layerHasFeatures(layer):\n            logger.info(f'Writing {str(layer.featureCount())} features to: {path}')\n        try:\n            options = QgsVectorFileWriter.SaveVectorOptions()\n            options.driverName = format\n            QgsVectorFileWriter.writeAsVectorFormatV3(layer, path, QgsProject.instance().transformContext(), options)\n            logger.info(\"Export completed\")\n        except Exception as error:\n            logger.error(\"An error occured exporting layer\")\n            logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n            logger.critical(\"Program terminated\")\n            script_failed()\n\n    def textfile(file: str, list: list, newline: bool):\n        \"\"\"\n        Create an output file from a list of lines. \n\n        Parameters\n        ----------\n        file : Path and filename\n            The file to be created.\n\n        list : List\n            List of lines to be written to the file.\n\n        newline : Boolean\n            If true, a newline character will be added to the end of each line.\n        \"\"\"\n        logger.info(\"Creating text file: \" + file)\n        try:\n            with open(file, 'w', encoding=\"utf-8\") as f:\n                for line in list:\n                    if newline == True:\n                        f.write(line + '\\\\n')\n                    else:\n                        f.write(line)\n            logger.info(\"File created\")\n        except Exception as error:\n            logger.error(\"An error occured creating file\")\n            logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n            logger.critical(\"Program terminated\")\n            script_failed()\n\n    def mssql(layer: QgsVectorLayer, connection: str, driver: str, schema: str, table: str, overwrite: str, geom_type: str, geom_name: str, ogr2ogr_params: str):\n        \"\"\"\n        A function that exports a QgsVectorLayer into a MSSQL database using ogr2ogr.\n        The function writes the data to a temporary geojson file, that is then importet to the database with ogr2ogr.\n\n        Parameters\n        ----------\n        layer : QgsVectorLayer\n            The QgsVectorLayer that is to be written to a file.\n\n        connection : String\n            The name of a connection from the settings.json file.\n\n        driver : String (Optional)\n            The driver used for writing to the database.\n            Default value is : 'SQL Server'.\n\n        schema : String\n            The target schema.\n\n        table : String\n            The target table.\n\n        overwrite : Boolean\n            Overwrite or append.\n\n        geom_type : String\n            Geometry type. One of geometry/geography.\n\n        geom_name : String\n            Name of the geometry coloumn.\n\n        ogr2ogr_params : String\n            Extra parameters for ogr2ogr besides the default.\n        \"\"\"\n\n        try:\n            config = get_config()\n            logger.info(f'Exporting {layer} to MSSQL Server')\n            dbconnection = config['DatabaseConnections'][connection]\n            conn = copy.copy(dbconnection)\n            conn['password'] = 'xxxxxxx'\n            logger.info(f'Connection: {str(conn)}')\n            logger.info(f'Creating temporary layer in Temp folder')\n            tmp_path = f'{config[\"TempFolder\"]}mssql_layer_{str(randrange(1000))}.geojson'\n            options = QgsVectorFileWriter.SaveVectorOptions()\n            options.driverName = 'GeoJSON'\n            QgsVectorFileWriter.writeAsVectorFormatV3(layer, tmp_path, QgsProject.instance().transformContext(), options)\n            logger.info('Temporary layer created')\n\n            ## ogr2ogr parameters\n            table = f'-nln \"{schema}.{table}\"'\n            geometry = f'-lco \"GEOM_TYPE={geom_type}\" -lco \"GEOM_NAME={geom_name}\"'\n\n            if driver != '':\n                mssql_driver = driver\n            else:\n                 mssql_driver = 'SQL Server'\n\n            if dbconnection['user'] == '' and dbconnection['password'] == '':\n                ogrconnection = f\"MSSQL:server={dbconnection['host']};driver={mssql_driver};database={dbconnection['databasename']};trusted_connection=yes;\"\n            else:\n                ogrconnection = f\"MSSQL:server={dbconnection['host']};driver=SQL Server;database={dbconnection['databasename']};uid={dbconnection['user']};pwd={dbconnection['password']}\"\n\n            if overwrite == True:\n                ow = '-overwrite'\n            else:\n                ow = ''\n\n            if ogr2ogr_params != '':\n                ep = ' ' + ogr2ogr_params\n            else:\n                ep = ''\n\n            ogr2ogrstring = f'{config[\"QGIS_bin_folder\"]}/ogr2ogr.exe --config MSSQLSPATIAL_USE_BCP FALSE -f \"MSSQLSpatial\" \"{ogrconnection}\" \"{tmp_path}\" {geometry} {table} -lco UPLOAD_GEOM_FORMAT=wkt {ep}  {ow}'\n            logger.info(f'Writing to MSSQL database {dbconnection[\"databasename\"]}, {table}')\n            ogr2ogrstring.join(' -progress')\n            run = subprocess.run(ogr2ogrstring, stderr=subprocess.STDOUT)\n            if run.stdout:\n                logger.info(run.stdout)\n            os.remove(tmp_path)\n            logger.info(f'Export to MSSQL completed')\n\n        except Exception as error:\n            try:\n                os.remove(tmp_path)\n            except:\n                pass\n\n            logger.error(\"An error occured exporting to MSSQL\")\n            logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n            logger.critical(\"Program terminated\")\n            script_failed()\n\n    def filegdb(layer: QgsVectorLayer, layername: str, path: str):\n        \"\"\"\n        A function that export a QgsVectorLayer into an ESRI File\n\n        Parameters\n        ----------\n        layer : QgsVectorLayer\n            The layer that is to be written to an ESRI File GeoDatabase\n        path : str\n            The full path for the ESRI File Geodatabase to be created\n        layername : str\n            The name of the resulting layer in the ESRI File Geodatabase\n        \"\"\"\n\n        if layerHasFeatures(layer):\n            logger.info(f'Writing {str(layer.featureCount())} features to: {path}')\n        try:\n            options = QgsVectorFileWriter.SaveVectorOptions()\n            options.driverName = 'OpenFileGDB'\n            options.layerName = layername\n            QgsVectorFileWriter.writeAsVectorFormatV3(layer, path, QgsProject.instance().transformContext(), options)\n        except Exception as error:\n            logger.error(\"An error occured exporting layer to ESRI File Geodatabase\")\n            logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n            logger.critical(\"Program terminated\")\n            script_failed()\n\n    def packageLayers(layers: list, path: str,  overwrite: bool, style: bool):\n        \"\"\"\n        Adds layers to a GeoPackage.\n        If the GeoPackage exists and Overwrite existing GeoPackage is checked, \n        it will be overwritten (removed and recreated). \n        If the GeoPackage exists and Overwrite existing GeoPackage is not checked, the layer will be appended.\n\n        Parameters\n        ----------\n        input : [vector: any] [list]\n            The (vector) layers to import into the GeoPackage. \n            Raster layers are not supported. If a raster layer is added, a QgsProcessingException will be thrown.\n\n        overwrite : [boolean]Default: False\n            If the specified GeoPackage exists, setting this option to True will make sure that it is deleted \n            and a new one will be created before the layers are added. If set to False, layers will be appended.\n\n        style : [boolean] Default: True\n            Save the layer styles\n\n        path : str\n            The full path for the Geopackage to be created\n\n        \"\"\"\n\n        logger.info(\"Performing packageLayers\")\n        logger.info(f'Processing {str(len(layers))} layers')\n        try:\n            parameter = {\n                'INPUT': layers,\n                'OVERWRITE': overwrite,\n                'SAVE_STYLES': style,\n                'OUTPUT': path\n            }\n            logger.info(f'Parameters: {str(parameter)}')\n            processing.run('native:package', parameter)['OUTPUT']           \n            logger.info(\"packageLayers finished\")\n        except Exception as error:\n            logger.error(\"An error occured in packageLayers\")\n            logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n            logger.critical(\"Program terminated\" )\n            script_failed()\n</code></pre>"},{"location":"outputs/#python.engine.outputs.Output_Writer.append_geopackage","title":"<code>append_geopackage(layer, layername, geopackage)</code>","text":"<p>Append a layer to an existing geopackage. If the new layer does not exist, it will be created. It it exists, the features will be appended to the layer.</p>"},{"location":"outputs/#python.engine.outputs.Output_Writer.append_geopackage--parameters","title":"Parameters","text":"<p>layer : QgsVectorLayer     The QgsVectorLayer that is to be written to a file</p> String <p>The name of the layer in the geopackage file</p> String <p>The full path for the geopackage to be created</p> Source code in <code>python\\engine\\outputs.py</code> <pre><code>def append_geopackage(layer: str, layername: str, geopackage: str):\n    \"\"\"\n    Append a layer to an existing geopackage.\n    If the new layer does not exist, it will be created. It it exists, the features will be appended to the layer.\n\n    Parameters\n    ----------\n    layer : QgsVectorLayer\n        The QgsVectorLayer that is to be written to a file\n\n    layername : String\n        The name of the layer in the geopackage file\n\n    geopackage : String\n        The full path for the geopackage to be created\n\n    \"\"\"\n    logger.info(\"Running append layer to Geopackage\")\n    if os.path.isfile(geopackage):\n        logger.info(f'Geopackage {geopackage} exists, appending layer')\n        tempfile = create_tempfile(layer, 'append_geopackage')\n\n        try:\n            config = get_config()\n            ## ogr2ogr parameters\n            table = f'-nln \"{layername}\"'\n            ogr2ogrstring = f'{config[\"QGIS_bin_folder\"]}/ogr2ogr.exe -f \"GPKG\" {geopackage} {tempfile} -nln {layername} -update -append'\n            logger.info(f'Writing new layer {layername} to: {geopackage}')\n            logger.info(f'Ogr2ogr command {ogr2ogrstring}')\n            ogr2ogrstring.join(' -progress')\n            run = subprocess.run(ogr2ogrstring, stderr=subprocess.STDOUT)\n            if run.stdout:\n                logger.info(run.stdout)\n            delete_tempfile(tempfile)\n            logger.info(f'Append to geopackage completed')\n\n        except Exception as error:\n            logger.error(\"An error occured appending layer to geopackage\")\n            logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n            logger.critical(\"Program terminated\")\n            script_failed() \n    else:\n        logger.error(\"Target geopackage not found\")\n        logger.critical(\"Program terminated\")\n        script_failed()     \n</code></pre>"},{"location":"outputs/#python.engine.outputs.Output_Writer.excel","title":"<code>excel(layer, path)</code>","text":"<p>A function that exports a QgsVectorLayer into an excel spredsheet.</p>"},{"location":"outputs/#python.engine.outputs.Output_Writer.excel--parameters","title":"Parameters","text":"<p>layer : QgsVectorLayer     The QgsVectorLayer to be exported into an excel spredsheet.</p> str <p>the ouput file to be created.</p> Source code in <code>python\\engine\\outputs.py</code> <pre><code>def excel(layer: QgsVectorLayer, path : str):\n    \"\"\"\n    A function that exports a QgsVectorLayer into an excel spredsheet.\n\n    Parameters\n    ----------\n    layer : QgsVectorLayer\n        The QgsVectorLayer to be exported into an excel spredsheet.\n\n    path : str\n        the ouput file to be created.\n\n    \"\"\"\n\n    if layerHasFeatures(layer):\n        logger.info(f'Writing {str(layer.featureCount())} features to Excel : {path}')\n    try:\n        parameter = {'LAYERS': [layer],\n                'USE_ALIAS': True,\n                'FORMATTED_VALUES': False,\n                'OUTPUT': path}\n        processing.run(\"native:exporttospreadsheet\", parameter)\n        logger.info(f'Parameters: {str(parameter)}')\n        logger.info(\"Export to Excel completed\")\n    except Exception as error:\n        logger.error(\"An error occured exporting layer to Excel\")\n        logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n        logger.critical(\"Program terminated\")\n        script_failed()\n</code></pre>"},{"location":"outputs/#python.engine.outputs.Output_Writer.file","title":"<code>file(layer, path, format)</code>","text":""},{"location":"outputs/#python.engine.outputs.Output_Writer.file--parameters","title":"Parameters","text":"<p>layer : QgsVectorLayer     The QgsVectorLayer that is to be written to a file</p> type <p>The full path for the file to be created</p> type <p>The driver type used to write the data to the file.</p> Source code in <code>python\\engine\\outputs.py</code> <pre><code>def file(layer: str, path: str, format: str):\n    \"\"\"\n    Parameters\n    ----------\n    layer : QgsVectorLayer\n        The QgsVectorLayer that is to be written to a file\n\n    path : _type_\n        The full path for the file to be created\n\n    format : _type_\n        The driver type used to write the data to the file. \n    \"\"\"\n\n    if layerHasFeatures(layer):\n        logger.info(f'Writing {str(layer.featureCount())} features to: {path}')\n    try:\n        options = QgsVectorFileWriter.SaveVectorOptions()\n        options.driverName = format\n        QgsVectorFileWriter.writeAsVectorFormatV3(layer, path, QgsProject.instance().transformContext(), options)\n        logger.info(\"Export completed\")\n    except Exception as error:\n        logger.error(\"An error occured exporting layer\")\n        logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n        logger.critical(\"Program terminated\")\n        script_failed()\n</code></pre>"},{"location":"outputs/#python.engine.outputs.Output_Writer.filegdb","title":"<code>filegdb(layer, layername, path)</code>","text":"<p>A function that export a QgsVectorLayer into an ESRI File</p>"},{"location":"outputs/#python.engine.outputs.Output_Writer.filegdb--parameters","title":"Parameters","text":"<p>layer : QgsVectorLayer     The layer that is to be written to an ESRI File GeoDatabase path : str     The full path for the ESRI File Geodatabase to be created layername : str     The name of the resulting layer in the ESRI File Geodatabase</p> Source code in <code>python\\engine\\outputs.py</code> <pre><code>def filegdb(layer: QgsVectorLayer, layername: str, path: str):\n    \"\"\"\n    A function that export a QgsVectorLayer into an ESRI File\n\n    Parameters\n    ----------\n    layer : QgsVectorLayer\n        The layer that is to be written to an ESRI File GeoDatabase\n    path : str\n        The full path for the ESRI File Geodatabase to be created\n    layername : str\n        The name of the resulting layer in the ESRI File Geodatabase\n    \"\"\"\n\n    if layerHasFeatures(layer):\n        logger.info(f'Writing {str(layer.featureCount())} features to: {path}')\n    try:\n        options = QgsVectorFileWriter.SaveVectorOptions()\n        options.driverName = 'OpenFileGDB'\n        options.layerName = layername\n        QgsVectorFileWriter.writeAsVectorFormatV3(layer, path, QgsProject.instance().transformContext(), options)\n    except Exception as error:\n        logger.error(\"An error occured exporting layer to ESRI File Geodatabase\")\n        logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n        logger.critical(\"Program terminated\")\n        script_failed()\n</code></pre>"},{"location":"outputs/#python.engine.outputs.Output_Writer.geopackage","title":"<code>geopackage(layer, layername, geopackage, overwrite)</code>","text":"<p>A function that writes a QgsVectorLayer to a Geopackage file. </p>"},{"location":"outputs/#python.engine.outputs.Output_Writer.geopackage--parameters","title":"Parameters","text":"<p>layer : QgsVectorLayer     The QgsVectorLayer that is to be written to the geopackage</p> String <p>The name of the layer in the geopackage file</p> String <p>The full path for the geopackage to be created</p> <p>overwrite : Boolean</p> <pre><code>Specify wheather the writer will overwrite existing geopackage or append layer. Boolean True/False\n</code></pre> Source code in <code>python\\engine\\outputs.py</code> <pre><code>def geopackage(layer: QgsVectorLayer, layername: str, geopackage: str, overwrite: bool):\n    \"\"\"\n    A function that writes a QgsVectorLayer to a Geopackage file. \n\n    Parameters\n    ----------\n    layer : QgsVectorLayer\n        The QgsVectorLayer that is to be written to the geopackage\n\n    layername : String\n        The name of the layer in the geopackage file\n\n    geopackage : String\n        The full path for the geopackage to be created\n\n    overwrite : Boolean\n\n        Specify wheather the writer will overwrite existing geopackage or append layer. Boolean True/False\n\n    \"\"\"\n\n    if layerHasFeatures(layer):\n        logger.info(f'Writing {str(layer.featureCount())} features to geopackage : {geopackage}')\n    try:\n        layer.setName(layername)\n        parameter = {'LAYERS': [layer],\n                'OUTPUT': geopackage,\n                'OVERWRITE': overwrite,\n                'SAVE_STYLES': False,\n                'SAVE_METADATA': False,\n                'SELECTED_FEATURES_ONLY': False}\n        processing.run(\"native:package\", parameter)\n        logger.info(f'Parameters: {str(parameter)}')\n        logger.info(\"Export to Geopackage completed\")\n    except Exception as error:\n        logger.error(\"An error occured exporting layer to geopackage\")\n        logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n        logger.critical(\"Program terminated\")\n        script_failed()\n</code></pre>"},{"location":"outputs/#python.engine.outputs.Output_Writer.mssql","title":"<code>mssql(layer, connection, driver, schema, table, overwrite, geom_type, geom_name, ogr2ogr_params)</code>","text":"<p>A function that exports a QgsVectorLayer into a MSSQL database using ogr2ogr. The function writes the data to a temporary geojson file, that is then importet to the database with ogr2ogr.</p>"},{"location":"outputs/#python.engine.outputs.Output_Writer.mssql--parameters","title":"Parameters","text":"<p>layer : QgsVectorLayer     The QgsVectorLayer that is to be written to a file.</p> String <p>The name of a connection from the settings.json file.</p> String (Optional) <p>The driver used for writing to the database. Default value is : 'SQL Server'.</p> String <p>The target schema.</p> String <p>The target table.</p> Boolean <p>Overwrite or append.</p> String <p>Geometry type. One of geometry/geography.</p> String <p>Name of the geometry coloumn.</p> String <p>Extra parameters for ogr2ogr besides the default.</p> Source code in <code>python\\engine\\outputs.py</code> <pre><code>def mssql(layer: QgsVectorLayer, connection: str, driver: str, schema: str, table: str, overwrite: str, geom_type: str, geom_name: str, ogr2ogr_params: str):\n    \"\"\"\n    A function that exports a QgsVectorLayer into a MSSQL database using ogr2ogr.\n    The function writes the data to a temporary geojson file, that is then importet to the database with ogr2ogr.\n\n    Parameters\n    ----------\n    layer : QgsVectorLayer\n        The QgsVectorLayer that is to be written to a file.\n\n    connection : String\n        The name of a connection from the settings.json file.\n\n    driver : String (Optional)\n        The driver used for writing to the database.\n        Default value is : 'SQL Server'.\n\n    schema : String\n        The target schema.\n\n    table : String\n        The target table.\n\n    overwrite : Boolean\n        Overwrite or append.\n\n    geom_type : String\n        Geometry type. One of geometry/geography.\n\n    geom_name : String\n        Name of the geometry coloumn.\n\n    ogr2ogr_params : String\n        Extra parameters for ogr2ogr besides the default.\n    \"\"\"\n\n    try:\n        config = get_config()\n        logger.info(f'Exporting {layer} to MSSQL Server')\n        dbconnection = config['DatabaseConnections'][connection]\n        conn = copy.copy(dbconnection)\n        conn['password'] = 'xxxxxxx'\n        logger.info(f'Connection: {str(conn)}')\n        logger.info(f'Creating temporary layer in Temp folder')\n        tmp_path = f'{config[\"TempFolder\"]}mssql_layer_{str(randrange(1000))}.geojson'\n        options = QgsVectorFileWriter.SaveVectorOptions()\n        options.driverName = 'GeoJSON'\n        QgsVectorFileWriter.writeAsVectorFormatV3(layer, tmp_path, QgsProject.instance().transformContext(), options)\n        logger.info('Temporary layer created')\n\n        ## ogr2ogr parameters\n        table = f'-nln \"{schema}.{table}\"'\n        geometry = f'-lco \"GEOM_TYPE={geom_type}\" -lco \"GEOM_NAME={geom_name}\"'\n\n        if driver != '':\n            mssql_driver = driver\n        else:\n             mssql_driver = 'SQL Server'\n\n        if dbconnection['user'] == '' and dbconnection['password'] == '':\n            ogrconnection = f\"MSSQL:server={dbconnection['host']};driver={mssql_driver};database={dbconnection['databasename']};trusted_connection=yes;\"\n        else:\n            ogrconnection = f\"MSSQL:server={dbconnection['host']};driver=SQL Server;database={dbconnection['databasename']};uid={dbconnection['user']};pwd={dbconnection['password']}\"\n\n        if overwrite == True:\n            ow = '-overwrite'\n        else:\n            ow = ''\n\n        if ogr2ogr_params != '':\n            ep = ' ' + ogr2ogr_params\n        else:\n            ep = ''\n\n        ogr2ogrstring = f'{config[\"QGIS_bin_folder\"]}/ogr2ogr.exe --config MSSQLSPATIAL_USE_BCP FALSE -f \"MSSQLSpatial\" \"{ogrconnection}\" \"{tmp_path}\" {geometry} {table} -lco UPLOAD_GEOM_FORMAT=wkt {ep}  {ow}'\n        logger.info(f'Writing to MSSQL database {dbconnection[\"databasename\"]}, {table}')\n        ogr2ogrstring.join(' -progress')\n        run = subprocess.run(ogr2ogrstring, stderr=subprocess.STDOUT)\n        if run.stdout:\n            logger.info(run.stdout)\n        os.remove(tmp_path)\n        logger.info(f'Export to MSSQL completed')\n\n    except Exception as error:\n        try:\n            os.remove(tmp_path)\n        except:\n            pass\n\n        logger.error(\"An error occured exporting to MSSQL\")\n        logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n        logger.critical(\"Program terminated\")\n        script_failed()\n</code></pre>"},{"location":"outputs/#python.engine.outputs.Output_Writer.packageLayers","title":"<code>packageLayers(layers, path, overwrite, style)</code>","text":"<p>Adds layers to a GeoPackage. If the GeoPackage exists and Overwrite existing GeoPackage is checked,  it will be overwritten (removed and recreated).  If the GeoPackage exists and Overwrite existing GeoPackage is not checked, the layer will be appended.</p>"},{"location":"outputs/#python.engine.outputs.Output_Writer.packageLayers--parameters","title":"Parameters","text":"<p>input : vector: any     The (vector) layers to import into the GeoPackage.      Raster layers are not supported. If a raster layer is added, a QgsProcessingException will be thrown.</p> [boolean]Default: False <p>If the specified GeoPackage exists, setting this option to True will make sure that it is deleted  and a new one will be created before the layers are added. If set to False, layers will be appended.</p> [boolean] Default: True <p>Save the layer styles</p> str <p>The full path for the Geopackage to be created</p> Source code in <code>python\\engine\\outputs.py</code> <pre><code>def packageLayers(layers: list, path: str,  overwrite: bool, style: bool):\n    \"\"\"\n    Adds layers to a GeoPackage.\n    If the GeoPackage exists and Overwrite existing GeoPackage is checked, \n    it will be overwritten (removed and recreated). \n    If the GeoPackage exists and Overwrite existing GeoPackage is not checked, the layer will be appended.\n\n    Parameters\n    ----------\n    input : [vector: any] [list]\n        The (vector) layers to import into the GeoPackage. \n        Raster layers are not supported. If a raster layer is added, a QgsProcessingException will be thrown.\n\n    overwrite : [boolean]Default: False\n        If the specified GeoPackage exists, setting this option to True will make sure that it is deleted \n        and a new one will be created before the layers are added. If set to False, layers will be appended.\n\n    style : [boolean] Default: True\n        Save the layer styles\n\n    path : str\n        The full path for the Geopackage to be created\n\n    \"\"\"\n\n    logger.info(\"Performing packageLayers\")\n    logger.info(f'Processing {str(len(layers))} layers')\n    try:\n        parameter = {\n            'INPUT': layers,\n            'OVERWRITE': overwrite,\n            'SAVE_STYLES': style,\n            'OUTPUT': path\n        }\n        logger.info(f'Parameters: {str(parameter)}')\n        processing.run('native:package', parameter)['OUTPUT']           \n        logger.info(\"packageLayers finished\")\n    except Exception as error:\n        logger.error(\"An error occured in packageLayers\")\n        logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n        logger.critical(\"Program terminated\" )\n        script_failed()\n</code></pre>"},{"location":"outputs/#python.engine.outputs.Output_Writer.postgis","title":"<code>postgis(layer, connection, dbname, schema, tablename, overwrite=True)</code>","text":"<p>A function that exports a QgsVectorLayer into a Postgis database.</p>"},{"location":"outputs/#python.engine.outputs.Output_Writer.postgis--parameters","title":"Parameters","text":"<p>layer : QgsVectorLayer     The QgsVectorLayer to be exported into Postgis</p> str <p>The name of the connection object in the settings file</p> str <p>The database name</p> str <p>Schema name</p> str <p>The name of the table that will be imported</p> bool <p>Defaults to True. Should the resulting table in Postgis be overwritten if it exists. If set to False, then it will append the data.</p> Source code in <code>python\\engine\\outputs.py</code> <pre><code>def postgis(layer: QgsVectorLayer, connection : str, dbname: str, schema: str, tablename: str, overwrite: bool = True):\n    \"\"\"\n    A function that exports a QgsVectorLayer into a Postgis database.\n\n    Parameters\n    ----------\n    layer : QgsVectorLayer\n        The QgsVectorLayer to be exported into Postgis\n\n    connection : str\n        The name of the connection object in the settings file\n\n    dbname : str\n        The database name\n\n    schema : str\n        Schema name\n\n    tablename : str\n        The name of the table that will be imported\n\n    overwrite : bool\n        Defaults to True. Should the resulting table in Postgis be overwritten if it exists. If set to False, then it will append the data.\n    \"\"\"\n\n    if layerHasFeatures(layer):\n        logger.info(f'Exporting {str(layer.featureCount())} features to Postgis')\n    tempfile = create_tempfile(layer, 'postgis')\n    logger.info('Temporary layer created')\n\n    try:\n        config = get_config()\n        dbConnection = config['DatabaseConnections'][connection]\n\n        # ogr2ogr parameters\n        table = f'-nln \"{schema}.{tablename}\"'\n        ogrconnection = f'PG:\"host={dbConnection[\"host\"]} port={dbConnection[\"port\"]} dbname={dbname} schemas={schema} user={dbConnection[\"user\"]} password={dbConnection[\"password\"]}\"'\n        ogr2ogrstring = f'{config[\"QGIS_bin_folder\"]}/ogr2ogr.exe -f \"PostgreSQL\" {ogrconnection} {tempfile} {table}'\n        if overwrite:\n            ogr2ogrstring = f'{ogr2ogrstring} -overwrite'\n        logger.info(f'Writing to PostGIS database {dbname}')\n        run = subprocess.run(ogr2ogrstring, capture_output=True)\n        delete_tempfile(tempfile)\n        logger.info('Temporary layer removed')\n        logger.info('Export to PostGIS completed')\n\n    except Exception as error:\n        logger.error(\"An error occured exporting to Postgis\")\n        logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n        logger.critical(\"Program terminated\")\n        script_failed()\n</code></pre>"},{"location":"outputs/#python.engine.outputs.Output_Writer.textfile","title":"<code>textfile(file, list, newline)</code>","text":"<p>Create an output file from a list of lines. </p>"},{"location":"outputs/#python.engine.outputs.Output_Writer.textfile--parameters","title":"Parameters","text":"<p>file : Path and filename     The file to be created.</p> List <p>List of lines to be written to the file.</p> Boolean <p>If true, a newline character will be added to the end of each line.</p> Source code in <code>python\\engine\\outputs.py</code> <pre><code>def textfile(file: str, list: list, newline: bool):\n    \"\"\"\n    Create an output file from a list of lines. \n\n    Parameters\n    ----------\n    file : Path and filename\n        The file to be created.\n\n    list : List\n        List of lines to be written to the file.\n\n    newline : Boolean\n        If true, a newline character will be added to the end of each line.\n    \"\"\"\n    logger.info(\"Creating text file: \" + file)\n    try:\n        with open(file, 'w', encoding=\"utf-8\") as f:\n            for line in list:\n                if newline == True:\n                    f.write(line + '\\\\n')\n                else:\n                    f.write(line)\n        logger.info(\"File created\")\n    except Exception as error:\n        logger.error(\"An error occured creating file\")\n        logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n        logger.critical(\"Program terminated\")\n        script_failed()\n</code></pre>"},{"location":"workers/","title":"Workers","text":""},{"location":"workers/#python.engine.workers.Worker","title":"<code>Worker</code>","text":"<p>Base class for transforming data.</p> Source code in <code>python\\engine\\workers.py</code> <pre><code>class Worker:\n    '''\n    Base class for transforming data.\n    '''\n\n    ## Method that draws the progress bar\n    def printProgressBar(value,label):\n        n_bar = 40 #size of progress bar\n        max = 100\n        j= value/max\n        sys.stdout.write('\\r')\n        bar = '\u2588' * int(n_bar * j)\n        bar = bar + '-' * int(n_bar * (1-j))\n        sys.stdout.write(f\"{label.ljust(10)} | [{bar:{n_bar}s}] {int(100 * j)}% \")\n        sys.stdout.flush()\n        sys.stdout.write('')        \n\n    ## The progress bar function\n    def progress_changed(progress):\n        Worker.printProgressBar(progress, '%')\n\n    ## The shared element for progress across all workers\n    progress = QgsProcessingFeedback()\n    progress.progressChanged.connect(progress_changed)\n\n    ## The shared element for logging across all workers\n    logger = get_logger() \n\n\n    class Vector:\n        '''\n        A Worker subclass that contains methods to transform vector data or their attributes.\n        '''\n\n        def attributeindex(layer: QgsVectorLayer, field: str):\n            \"\"\"\n            Creates an index to speed up queries made against a field in a table.\n            Support for index creation is dependent on the layer's data provider and the field type.\n\n            Parameters\n            ----------\n            layer : QgsVectorLayer [vector: any]\n                The QgsVectorLayer input for the algorithem\n\n            field : Field\n                The field to base the index on\n\n            Returns\n            -------\n            QgsVectorLayer [vector: any]\n                The result output from the algorithem\n            \"\"\"\n            logger.info(\"Crating attribute index on \" + layer + \" on filed \" + field)\n            try:\n                parameter = {\n                    'INPUT': field,\n                    'FIELD': field,\n                    'OUTPUT': 'memory:extracted'\n                }\n                result = processing.run('native:createattributeindex', parameter, feedback=Worker.progress)['OUTPUT']\n                logger.info(f'Parameters: {str(parameter)}')\n                logger.info(\"createattributeindex  finished\")\n                return result\n            except Exception as error:\n                logger.error(\"An error occured in createattributeindex\")\n                logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n                logger.critical(\"Program terminated\" )\n                sys.exit()\n\n        def addxyfieldstolayer(layer: QgsVectorLayer, crs: str):\n            \"\"\"\n            Adds X and Y (or latitude/longitude) fields to a point layer. The X/Y fields can be calculated in a different CRS to the layer (e.g. creating latitude/longitude fields for a layer in a projected CRS).\n\n            Parameters\n            ----------\n            layer : QgsVectorLayer\n                The input layer.\n\n            crs : str\n                Coordinate reference system to use for the generated x and y fields.\n\n            Returns\n            -------\n\n            QgsVectorLayer\n                Specify the output layer.\n            \"\"\"\n            logger.info(f\"Adding X/Y fields to {layer}\" )\n            try:\n                parameter = {\n                    'INPUT': layer,\n                    'CRS': crs,\n                    'OUTPUT': 'memory:output_from_addxyfieldstolayer'\n                }\n                result = processing.run('native:addxyfieldstolayer', parameter, feedback=Worker.progress)['OUTPUT']\n                logger.info(f'Parameters: {str(parameter)}')\n                logger.info(\"addxyfieldstolayer  finished\")\n                return result\n            except Exception as error:\n                logger.error(\"An error occured in addxyfieldstolayer\")\n                logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n                logger.critical(\"Program terminated\" )\n                sys.exit()\n\n        def convexhull(layer: QgsVectorLayer):\n            \"\"\"\n            Calculates the convex hull for each feature in an input layer.\n\n            Parameters\n            ----------\n            layer : QgsVectorLayer\n                Input vector layer\n\n            Returns\n            -------\n            QgsVectorLayer\n                Specify the output vector layer.\n            \"\"\"\n            logger.info(f\" Calculating convexhull for layer {layer}\")\n            try:\n                parameter = {\n                    'INPUT': layer,\n                    'OUTPUT': 'memory:output_from_convexhull'\n                }\n                result = processing.run('native:convexhull', parameter, feedback=Worker.progress)['OUTPUT']\n                logger.info(f'Parameters: {str(parameter)}')\n                logger.info(\"convexhull  finished\")\n                return result\n            except Exception as error:\n                logger.error(\"An error occured in convexhull\")\n                logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n                logger.critical(\"Program terminated\" )\n                sys.exit()\n\n        def concavehull(inputlayer:QgsVectorLayer, alpha: float, holes: bool, multigeom: bool ):\n            \"\"\"\n            Computes the concave hull of the features from an input point layer.\n\n            Parameters\n            ----------\n            inputlayer : QgsVectorLayer [point]\n                Input point vector layer\n\n            alpha : float\n                Number from 0 (maximum concave hull) to 1 (convex hull).\n\n            holes : bool\n                Choose whether to allow holes in the final concave hull\n\n            multigeom : bool\n                Check if you want to have singlepart geometries instead of multipart ones.\n\n            Returns\n            -------\n            QgsVectorLayer [polygon]\n                Specify the output vector layer\n            \"\"\"\n            logger.info('calcualting concavehull')\n            try:\n                parameters = {\n                    'INPUT': inputlayer,\n                    'ALPHA' : alpha,\n                    'HOLES' : holes,\n                    'NO_MULTIGEOMETRY' : multigeom,\n                    'OUTPUT': 'memory:output_from_concavehull'\n                }\n                logger.info(f'Parameters: {str(parameters)}')\n                result = processing.run('native:concavehull', parameters, feedback=Worker.progress)['OUTPUT']\n                logger.info('concavehull finished')\n                return result\n            except Exception as error:\n                logger.error(\"An error occured in concavehull\")\n                logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n                logger.critical(\"Program terminated\" )\n                script_failed()            \n\n        def extractvertices(inputlayer:QgsVectorLayer):\n            \"\"\"\n            Takes a vector layer and generates a point layer with points representing the vertices in the input geometries.\n            The attributes associated to each point are the same ones associated to the feature that the vertex belongs to.\n            Additional fields are added to the vertices indicating the vertex index (beginning at 0), the feature\u2019s part and its index within the part\n            (as well as its ring for polygons), distance along original geometry and bisector angle of vertex for original geometry.\n\n            Parameters\n            ----------\n            inputlayer : QgsVectorLayer\n                Input vector layer\n\n            Returns\n            -------\n            QgsVectorLayer [point]\n                Specify the output vector layer\n            \"\"\"\n            logger.info('Extracting vertices')\n            try:\n                parameters = {\n                    'INPUT': inputlayer,\n                    'OUTPUT': 'memory:output_from_extractvertices'\n                }\n                logger.info(f'Parameters: {str(parameters)}')\n                result = processing.run('native:extractvertices', parameters, feedback=Worker.progress)['OUTPUT']\n                logger.info('extractvertices finished')\n                return result\n            except Exception as error:\n                logger.error(\"An error occured in extractvertices\")\n                logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n                logger.critical(\"Program terminated\" )\n                script_failed()    \n\n        def multiringconstantbuffer(inputlayer:QgsVectorLayer, rings: int, distance : str):\n            \"\"\"\n            Computes multi-ring (donut) buffer for the features of the input layer, using a fixed or dynamic distance and number of rings.\n\n            Parameters\n            ----------\n            inputlayer : QgsVectorLayer\n                Input vector layer\n\n            rings : int\n                The number of rings. It can be a unique value (same number of rings for all the features) or it can be taken from features data (the number of rings depends on feature values).\n\n            distance : str\n                Distance between the rings. It can be a unique value (same distance for all the features) or it can be taken from features data (a field in the input data layer).\n\n            Returns\n            -------\n            QgsVectorLayer [polygon]\n                Specify the output polygon vector layer\n\n            \"\"\"\n            logger.info('Creating multiringconstantbuffer')\n            try:\n                dist = float(distance)\n                logger.info('Using distance value')\n            except:\n                dist = QgsProperty.fromExpression(f'\"{distance}\"')\n                logger.info('Using distance from field')\n\n            try:\n                parameters = {\n                    'INPUT': inputlayer,\n                    'RINGS': rings,\n                    'DISTANCE': distance,\n                    'OUTPUT': 'memory:output_from_multiringconstantbuffer'\n                }\n                logger.info(f'Parameters: {str(parameters)}')\n                result = processing.run('native:multiringconstantbuffer', parameters, feedback=Worker.progress)['OUTPUT']\n                logger.info('multiringconstantbuffer finished')\n                return result\n            except Exception as error:\n                logger.error(\"An error occured in multiringconstantbuffer\")\n                logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n                logger.critical(\"Program terminated\" )\n                script_failed() \n\n        def poleofinaccessibility(inputlayer:QgsVectorLayer, tolerance: int):\n            \"\"\"\n            Calculates the pole of inaccessibility for a polygon layer, which is the most distant internal point from the boundary of the surface. \n            This algorithm uses the \u2018polylabel\u2019 algorithm (Vladimir Agafonkin, 2016), which is an iterative approach guaranteed to find the true pole of inaccessibility within\n            a specified tolerance. A more precise tolerance (lower value) requires more iterations and will take longer to calculate. \n            The distance from the calculated pole to the polygon boundary will be stored as a new attribute in the output layer.\n\n            Parameters\n            ----------\n            inputlayer : QgsVectorLayer [polygon]\n                Input vector layer\n\n            tolerance : int\n                Set the tolerance for the calculation. Default 1\n\n            Returns\n            -------\n            QgsVectorLayer [point]\n                Specify the output polygon vector layer.\n            \"\"\"\n            logger.info('calcualting poleofinaccessibility')\n            try:\n                parameters = {\n                    'INPUT': inputlayer,\n                    'TOLERANCE' : tolerance,\n                    'OUTPUT': 'memory:output_from_poleofinaccessibility'\n                }\n                logger.info(f'Parameters: {str(parameters)}')\n                result = processing.run('native:poleofinaccessibility', parameters, feedback=Worker.progress)['OUTPUT']\n                logger.info('poleofinaccessibility finished')\n                return result\n            except Exception as error:\n                logger.error(\"An error occured in poleofinaccessibility\")\n                logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n                logger.critical(\"Program terminated\" )\n                script_failed()\n\n\n        def symmetricaldifference(inputlayer: QgsVectorLayer, overlay_layer: QgsVectorLayer):\n            \"\"\"\n            Creates a layer containing features from both the input and overlay layers but with the overlapping areas between the two layers removed.\n            The attribute table of the symmetrical difference layer contains attributes and fields from both the input and overlay layers.\n\n            Parameters\n            ----------\n            inputlayer : QgsVectorLayer\n                First layer to extract (parts of) features from.\n\n            overlay_layer : QgsVectorLayer\n                Second layer to extract (parts of) features from. Ideally the geometry type should be the same as input layer.\n\n            Returns\n            -------\n            QgsVectorLayer\n                Specify the layer to contain (the parts of) the features from the input and overlay layers that do not overlap features from the other layer\n            \"\"\"\n\n            logger.info('calcualting symetrical difference')\n            try:\n                parameters = {\n                    'INPUT': inputlayer,\n                    'OVERLAY' : overlay_layer,\n                    'OUTPUT': 'memory:output_from_symmetricaldifference'\n                }\n                logger.info(f'Parameters: {str(parameters)}')\n                result = processing.run('native:symmetricaldifference', parameters, feedback=Worker.progress)['OUTPUT']\n                logger.info('Symmetricaldifference finished')\n                return result\n            except Exception as error:\n                logger.error(\"An error occured in symmetricaldifference\")\n                logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n                logger.critical(\"Program terminated\" )\n                script_failed()\n\n        def lineintersections(inputlayer: QgsVectorLayer, split_layer: QgsVectorLayer, input_fields: list, intersect_fields: list):\n            \"\"\"\n            Splits the lines or polygons in one layer using the lines or polygon rings in another layer to define the breaking points. Intersection between geometries in both layers are considered as split points.\n            Output will contain multi geometries for split features.\n\n            Parameters\n            ----------\n            inputlayer : QgsVectorLayer\n                Input line layer.\n\n            split_layer : QgsVectorLayer\n                Layer to use to find line intersections.\n\n            input_fields : list\n                Field(s) of the input layer to keep in the output. If no fields are chosen all fields are taken.\n\n            intersect_fields : list\n                Field(s) of the intersect layer to keep in the output. If no fields are chosen all fields are taken. Duplicate field names will be appended a count suffix to avoid collision\n\n            Returns\n            -------\n            QgsVectorLayer\n                Specify the layer to contain the intersection points of the lines from the input and overlay layers.\n\n            \"\"\"\n            logger.info('Performing line intersections')\n            try:\n                parameters = {\n                    'INPUT': inputlayer,\n                    'INTERSECT': split_layer,\n                    'INPUT_FIELDS' : input_fields, \n                    'INTERSECT_FIELDS' : intersect_fields,\n                    'OUTPUT': 'memory:output_from_lineintersections'\n                }\n                logger.info(f'Parameters: {str(parameters)}')\n                result = processing.run('native:lineintersections', parameters, feedback=Worker.progress)['OUTPUT']\n                logger.info('Lineintersections finished')\n                return result\n            except Exception as error:\n                logger.error(\"An error occured in Lineintersections\")\n                logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n                logger.critical(\"Program terminated\" )\n                script_failed()\n\n        def kmeansclustering(inputlayer: QgsVectorLayer, clusters: int):\n            \"\"\"\n            Calculates the 2D distance based k-means cluster number for each input feature.\n            K-means clustering aims to partition the features into k clusters in which each feature belongs to the cluster with the nearest mean. The mean point is represented by the barycenter of the clustered features.\n            If input geometries are lines or polygons, the clustering is based on the centroid of the feature.\n\n            Parameters\n            ----------\n            inputlayer : QgsVectorLayer\n                Layer to analyze\n\n            clusters : int\n                Number of clusters to create with the features\n\n            Returns\n            -------\n            QgsVectorLayer\n                Specify the output vector layer for generated the clusters.\n            \"\"\"\n\n            logger.info('Calculating clusters')\n            try:\n                parameters = {\n                    'INPUT': inputlayer,\n                    'CLUSTERS' : clusters,\n                    'OUTPUT': 'memory:output_from_kmeansclustering'\n                }\n                logger.info(f'Parameters: {str(parameters)}')\n                result = processing.run('native:kmeansclustering', parameters, feedback=Worker.progress)['OUTPUT']\n                logger.info('Kmeansclustering finished')\n                return result\n            except Exception as error:\n                logger.error(\"An error occured in Kmeansclustering\")\n                logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n                logger.critical(\"Program terminated\" )\n                script_failed()\n\n        def dbscanclustering(inputlayer: QgsVectorLayer, min_clusters: int, max_dist: int ):\n            \"\"\"\n            Clusters point features based on a 2D implementation of Density-based spatial clustering of applications with noise (DBSCAN) algorithm.\n            The algorithm requires two parameters, a minimum cluster size, and the maximum distance allowed between clustered points.\n\n            Parameters\n            ----------\n            inputlayer : QgsVectorLayer\n                Layer to analyze\n\n            min_clusters : int\n                Minimum number of features to generate a cluster\n\n            max_dist : int\n                Distance beyond which two features can not belong to the same cluster (eps)\n\n            Returns\n            -------\n            QgsVectorLayer\n                Specify the vector layer for the result of the clustering.\n            \"\"\"\n            logger.info('Performing DBScan clustering')\n            try:\n                parameters = {\n                    'INPUT': inputlayer,\n                    'MIN_SIZE' : min_clusters,\n                    'EPS': max_dist,\n                    'OUTPUT': 'memory:output_from_dbscanclustering'\n                }\n                logger.info(f'Parameters: {str(parameters)}')\n                result = processing.run('native:dbscanclustering', parameters, feedback=Worker.progress)['OUTPUT']\n                logger.info('Dbscanclustering finished')\n                return result\n            except Exception as error:\n                logger.error(\"An error occured in Dbscanclustering\")\n                logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n                logger.critical(\"Program terminated\" )\n                script_failed()\n\n        def countpointsinpolygon(polygons: QgsVectorLayer, points: QgsVectorLayer, weight : str, fieldname: str):\n            \"\"\"\n            Takes a point and a polygon layer and counts the number of points from the point layer in each of the polygons of the polygon layer.\n            A new polygon layer is generated, with the exact same content as the input polygon layer, but containing an additional field with the points count corresponding to each polygon.\n\n            Parameters\n            ----------\n            polygons : QgsVectorLayer\n                Polygon layer whose features are associated with the count of points they contain\n\n            points : QgsVectorLayer\n                Point layer with features to count\n\n            weight : str\n                A field from the point layer. The count generated will be the sum of the weight field of the points contained by the polygon. \n                If the weight field is not numeric, the count will be 0.\n\n            fieldname : str\n                The name of the field to store the count of points\n\n            Returns\n            -------\n            QgsVectorLayer\n                Specification of the output layer.\n            \"\"\"\n            logger.info('Conducting point in polygon')\n            try:\n                if isinstance(weight, int):\n                    value = weight\n                else:\n                    value = 0\n\n                parameters = {\n                    'POLYGONS': polygons,\n                    'POINTS': points,\n                    'WEIGHT': value,\n                    'FIELD' : fieldname,\n                    'OUTPUT': 'memory:output_from_countpointsinpolygon'\n                }\n                logger.info(f'Parameters: {str(parameters)}')\n                result = processing.run('native:Countpointsinpolygon', parameters, feedback=Worker.progress)['OUTPUT']\n                logger.info('Promote to multipart finished')\n                return result\n            except Exception as error:\n                logger.error(\"An error occured in Countpointsinpolygon\")\n                logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n                logger.critical(\"Program terminated\" )\n                script_failed()  \n\n        def promoteToMultipart(layer: QgsVectorLayer):\n            \"\"\"\n            Generates a vectorlayer in which all geometries are multipart.\n\n            Parameters\n            ----------\n            layer : QgsVectorLayer\n                The QgsVectorLayer that is used as input.\n\n            Returns\n            -------\n            QgsVectorLayer\n                The QgsVectorLayer containing multi geometries.\n            \"\"\"\n\n            logger.info('Collecting geometries')\n            try:\n                parameters = {\n                    'INPUT': layer,\n                    'OUTPUT': 'memory:multipart'\n                }\n                logger.info(f'Parameters: {str(parameters)}')\n                result = processing.run('native:promotetomulti', parameters, feedback=Worker.progress)['OUTPUT']\n                logger.info('Promote to multipart finished')\n                return result\n            except Exception as error:\n                logger.error(\"An error occured in promoteToMultipart\")\n                logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n                logger.critical(\"Program terminated\" )\n                script_failed()\n\n        def extractByExpression(layer: QgsVectorLayer, expression: str):\n            \"\"\"\n            Creates a vector layer from an input layer, containing only matching features.\n            The criteria for adding features to the resulting layer is based on a QGIS expression.\n\n            Parameters\n            ----------\n            layer : QgsVectorLayer\n                The QgsVectorLayer that is used as input.\n\n            expression : String\n                Expression to filter the vector layer\n\n            Returns\n            -------\n            QgsVectorLayer\n                The QgsVectorLayer output layer.\n            \"\"\"\n            logger.info(\"Extracting by expression\")\n            try:\n                parameter = {\n                    'INPUT': layer,\n                    'EXPRESSION': expression,\n                    'OUTPUT': 'memory:extracted'\n                }\n                logger.info(f'Parameters: {str(parameter)}')\n                result = processing.run('native:extractbyexpression', parameter, feedback=Worker.progress)['OUTPUT']\n                logger.info(\"Extractbyexpression  finished\")\n                return result\n            except Exception as error:\n                logger.error(\"An error occured in extractByExpression\")\n                logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n                logger.critical(\"Program terminated\" )\n                sys.exit()\n\n        def renameTableField (layer: QgsVectorLayer, field: str, newname: str):\n            \"\"\"\n            Renames an existing field from a vector layer.  \n            The original layer is not modified. A new layer is generated where the attribute table contains the renamed field.\n            QGIS processing algorithem: native:renametablefield\n\n            Parameters\n            ----------\n            layer : QgsVectorLayer [vector: any]\n                The QgsVectorLayer input for the algorithem\n\n            field : Tablefield\n                The field that is to be renamed\n\n            newname : String\n                New name for the field\n\n\n            Returns\n            -------\n            QgsVectorLayer [vector: any]\n                The result output from the algorithem\n            \"\"\"\n            logger.info(\"Renaming field\")\n            try:\n                parameter = {\n                    'INPUT': layer,\n                    'FIELD': field,\n                    'NEW_NAME': newname,\n                    'OUTPUT': 'memory:extracted'\n                }\n                result = processing.run('native:renametablefield', parameter, feedback=Worker.progress)['OUTPUT']\n                logger.info(f'Parameters: {str(parameter)}')\n                logger.info(\"renameTableField  finished\")\n                return result\n            except Exception as error:\n                logger.error(\"An error occured in renameTableField\")\n                logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n                logger.critical(\"Program terminated\" )\n                sys.exit()\n\n        def timeStamper(layer: QgsVectorLayer, ts_fieldname: str):\n            \"\"\"\n                Create an attribute woth current timestamp on features.\n\n            Parameters\n            ----------\n            layer : QgsVectorLayer [vector: any]\n                The QgsVectorLayer input for the algorithem\n\n            ts_fieldname : String\n                The name of the new timestamp field\n\n            Returns\n            -------\n            QgsVectorLayer [vector: any]\n                The result output from the algorithem\n            \"\"\"\n            logger.info(f'Creating timestamp {ts_fieldname} using fieldCalculator')\n            newLayer = Worker.fieldCalculator(layer, ts_fieldname, 5, 0, 0, ' now() ')\n            return newLayer\n\n        def fieldCalculator (layer: QgsVectorLayer, fieldname: str, fieldtype: int, fieldlength: int, fieldprecision: int, formula: str):\n            \"\"\"\n            Scripting the field calcualtor\n            You can use all the supported expressions and functions.\n            The original layer is not modified. A new layer is generated where the attribute table contains the calucalted field\n            QGIS processing algorithem: native:fieldcalculator\n\n            Parameters\n            ----------\n            layer : QgsVectorLayer [vector: any]\n                The QgsVectorLayer input for the algorithem\n\n            fieldname : String\n                The name of the new calcualted field\n\n            fieldtype : Enumeration\n                Type of the field,  Default: 0  (0 \u2014 Float, 1 \u2014 Integer, 2 \u2014 String, 3 \u2014 Date)\n\n            fieldlength : Integer\n                Lenght of the field, Default: 10.\n\n            fieldprecision : Integer\n                Precision of the field, Default: 3.\n\n            formula : Expression\n                The expression that populates the values of the field.\n\n\n            Returns\n            -------\n            QgsVectorLayer [vector: any]\n                The result output from the algorithem\n            \"\"\"\n            logger.info(\"Calculating field\")\n            try:\n                parameter = {\n                    'INPUT': layer,\n                    'FIELD_NAME': fieldname,\n                    'FIELD_TYPE': fieldtype,\n                    'FIELD_LENGTH': fieldlength,\n                    'FIELD_PRECISION': fieldprecision,\n                    'FORMULA': formula,\n                    'OUTPUT': 'memory:extracted'\n                }\n                result = processing.run('native:fieldcalculator', parameter, feedback=Worker.progress)['OUTPUT']\n                logger.info(f'Parameters: {str(parameter)}')\n                logger.info(\"fieldCalculator  finished\")\n                return result\n            except Exception as error:\n                logger.error(\"An error occured in fieldCalculator\")\n                logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n                logger.critical(\"Program terminated\" )\n                sys.exit()\n\n        def deleteColumns (layer: QgsVectorLayer, columns: list):\n            \"\"\"\n            Takes a vector layer and generates a new one that has the same features but without the selected columns.\n\n            Parameters\n            ----------\n            layer : QgsVectorLayer\n                Input vector layer to drop field(s) from\n\n            columns : List of tablefields\n                The field(s) to drop\n\n            Returns\n            -------\n            QgsVectorLayer\n                The QgsVectorLayer output layer.\n            \"\"\"\n            logger.info(\"deleting fields\")\n\n            try:\n                parameter = {\n                    'INPUT': layer,\n                    'COLUMN':columns,\n                    'OUTPUT': 'memory:extracted'\n                }\n                result = processing.run('native:deletecolumn', parameter, feedback=Worker.progress)['OUTPUT']\n                logger.info(f'Parameters: {str(parameter)}')\n                logger.info(\"deleteColumns  finished\")\n                return result\n            except Exception as error:\n                logger.error(\"An error occured in deleteColumns\")\n                logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n                logger.critical(\"Program terminated\" )\n                sys.exit()\n\n        def addAutoIncrementalField(layer: QgsVectorLayer, fieldname: str, start: int):\n            \"\"\"\n            Adds a new integer field to a vector layer, with a sequential value for each feature.\n            This field can be used as a unique ID for features in the layer. The new attribute is not added to the input layer but a new layer is generated instead.\n            The initial starting value for the incremental series can be specified. Optionally, the incremental series can be based on grouping \n            fields and a sort order for features can also be specified.\n\n            Parameters\n            ----------\n            layer : QgsVectorLayer\n                The QgsVectorLayer that is used as input.\n\n            fieldname : String\n                Name of the field with autoincremental values.\n\n            start : Integer\n                Choose the initial number of the incremental count, Default: 0.\n\n            Returns\n            -------\n            QgsVectorLayer\n                The QgsVectorLayer output layer.\n            \"\"\"\n            logger.info(\"Adding incremental field\")\n            try:\n                parameter = {\n                    'INPUT': layer,\n                    'FIELD_NAME': fieldname,\n                    'START':start,\n                    'MODULUS':0,\n                    'GROUP_FIELDS':[],\n                    'SORT_EXPRESSION':'',\n                    'SORT_ASCENDING':True,\n                    'SORT_NULLS_FIRST':False,\n                    'OUTPUT': 'memory:extracted'\n                }\n                result = processing.run('native:addautoincrementalfield', parameter, feedback=Worker.progress)['OUTPUT']\n                logger.info(f'Parameters: {str(parameter)}')\n                logger.info(\"addAutoIncrementalField  finished\")\n                return result\n            except Exception as error:\n                logger.error(\"An error occured in addAutoIncrementalField\")\n                logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n                logger.critical(\"Program terminated\" )\n                sys.exit()\n\n        def spatialindex(layer: QgsVectorLayer):\n            \"\"\"\n            Creates an index to speed up access to the features in a layer based on their spatial location.\n            Support for spatial index creation is dependent on the layer's data provider.\n\n            Parameters\n            ----------\n            layer : QgsVectorLayer [vector: any]\n                The QgsVectorLayer input for the algorithem\n\n            Returns\n            -------\n            QgsVectorLayer [vector: any]\n                The result output from the algorithem\n            \"\"\"\n\n            logger.info(\"Crating spatial index on \" + layer)\n            try:\n                parameter = {\n                    'INPUT': layer,\n                    'OUTPUT': 'memory:extracted'\n                }\n                result = processing.run('native:createspatialindex', parameter, feedback=Worker.progress)['OUTPUT']\n                logger.info(f'Parameters: {str(parameter)}')\n                logger.info(\"createspatialindex  finished\")\n                return result\n            except Exception as error:\n                logger.error(\"An error occured in createspatialindex\")\n                logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n                logger.critical(\"Program terminated\" )\n                sys.exit()\n\n        def clip(layer: QgsVectorLayer, overlay: str):\n            \"\"\"\n            Clips a vector layer using the features of an additional polygon layer.\n            Only the parts of the features in the input layer that fall within the polygons of \n            the overlay layer will be added to the resulting layer.\n\n            Parameters\n            ----------\n            layer : QgsVectorLayer [vector: any]\n                Layer containing the features to be clipped\n\n            overlay : [vector: polygon]\n                Layer containing the clipping features\n\n            Returns\n            -------\n            QgsVectorLayer [vector: any]\n                Layer to contain the features from the input layer that are inside the overlay (clipping) layer\n            \"\"\"\n            logger.info(\"Clipping layers\")\n            try:\n                parameter = {\n                    'INPUT': layer,\n                    'OVERLAY': overlay,\n                    'OUTPUT': 'memory:extracted'\n                }\n                logger.info(f'Parameters: {str(parameter)}')\n                result = processing.run('native:clip', parameter, feedback=Worker.progress)['OUTPUT']\n                logger.info(\"Clip  finished\")\n                return result\n            except Exception as error:\n                logger.error(\"An error occured in Clip\")\n                logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n                logger.critical(\"Program terminated\" )\n                sys.exit()\n\n        def joinByLocation(layer: QgsVectorLayer, predicate: int, join: str, join_fields: list, method: int, discard_nomatching: bool, prefix: str):\n            \"\"\"\n            Takes an input vector layer and creates a new vector layer that is an extended version of\n            the input one, with additional attributes in its attribute table.\n            The additional attributes and their values are taken from a second vector layer.\n            A spatial criteria is applied to select the values from the second layer that are added to each \n            feature from the first layer.\n\n            Parameters\n            ----------\n            layer : QgsVectorLayer [vector: any]\n                Input vector layer. \n                The output layer will consist of the features of this layer with attributes from \n                matching features in the second layer.\n\n            predicate : [enumeration] Default: [0]\n                Type of spatial relation the source feature should have with the target feature so that they could be joined. One or more of:\n                0 \u2014 intersect, 1 \u2014 contain, 2 \u2014 equal, 3 \u2014 touch, 4 \u2014 overlap, 5 \u2014 are within 6 \u2014 cross.\n\n            join : [vector: any]\n                The join layer. \n                Features of this vector layer will add their attributes to the source layer attribute table if \n                they satisfy the spatial relationship.\n\n            join_fields : [tablefield: any] [list]\n                Select the specific fields you want to add from the join layer. \n                By default all the fields are added.\n\n            method : [enumeration]           \t\n                The type of the final joined layer. One of: \n                0 \u2014 Create separate feature for each matching feature (one-to-many)\n                1 \u2014 Take attributes of the first matching feature only (one-to-one)\n                2 \u2014 Take attributes of the feature with largest overlap only (one-to-one)\n\n            discard_nomatching : [boolean] Default: False\n                Remove from the output the input layer\u2019s features which could not be joined\n\n            prefix : [string]\n                Add a prefix to joined fields in order to easily identify them and avoid field name collision\n\n            Returns\n            -------\n            QgsVectorLayer [vector: any]\n                the output vector layer for the join.\n            \"\"\"\n            logger.info(\"Clipping layers\")\n            try:\n                parameter = {\n                    'INPUT': layer,\n                    'PREDICATE':predicate,\n                    'JOIN':join,\n                    'JOIN_FIELDS':join_fields,\n                    'METHOD':method,\n                    'DISCARD_NONMATCHING':discard_nomatching,\n                    'PREFIX':prefix,\n                    'OUTPUT': 'memory:extracted'\n                }\n                logger.info(f'Parameters: {str(parameter)}')\n                result = processing.run('native:joinattributesbylocation', parameter, feedback=Worker.progress)['OUTPUT']\n                logger.info(\"joinByLocation finished\")\n                return result\n            except Exception as error:\n                logger.error(\"An error occured in joinByLocation\")\n                logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n                logger.critical(\"Program terminated\" )\n                sys.exit()\n\n        def extractByLocation(layer: QgsVectorLayer, predicate: int, intersect: str):\n            \"\"\"_summary_\n\n            Parameters\n            ----------\n            layer : QgsVectorLayer [vector: any]\n                Input vector layer. \n\n            predicate : [enumeration] Default: [0]\n                Type of spatial relation the source feature should have with the target feature so that they could be joined. One or more of:\n                0 \u2014 intersect, 1 \u2014 contain, 2 \u2014 equal, 3 \u2014 touch, 4 \u2014 overlap, 5 \u2014 are within 6 \u2014 cross.\n\n            intersect : QgsVectorLayer [vector: any]\n                Intersection vector layer\n\n            Returns\n            -------\n            QgsVectorLayer [vector: any]\n                the output vector layer for the join.\n            \"\"\"\n            logger.info(\"Extracting by location\")\n            try:\n                parameter = {\n                    'INPUT': layer,\n                    'PREDICATE':predicate,\n                    'INTERSECT':intersect,\n                    'OUTPUT': 'memory:extracted'\n                }\n                logger.info(f'Parameters: {str(parameter)}')\n                result = processing.run('native:extractbylocation', parameter, feedback=Worker.progress)['OUTPUT']\n                logger.info(\"extractByLocation finished\")\n                return result\n            except Exception as error:\n                logger.error(\"An error occured in extractByLocation\")\n                logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n                logger.critical(\"Program terminated\" )\n                sys.exit()\n\n        def randomExtract(layer: QgsVectorLayer, method: int, number: int):\n            \"\"\"\n            Takes a vector layer and generates a new one that contains only a subset of the features in the input layer.\n            The subset is defined randomly, based on feature IDs, using a percentage or count value to define \n            the total number of features in the subset.\n\n            Parameters\n            ----------\n            layer : QgsVectorLayer [vector: any]\n                Input vector layer. \n\n            method : [enumeration] Default: 0\n                Random selection method. One of: 0 \u2014 Number of selected features 1 \u2014 Percentage of selected features\n\n            number : [number] Default: 10\n                Number or percentage of features to select\n\n            Returns\n            -------\n            QgsVectorLayer [vector: polygon/line]\n                The result output from the algorithem\n            \"\"\"\n            logger.info(\"Extracting random features\")\n            try:\n                parameter = {\n                    'INPUT': layer,\n                    'METHOD':method,\n                    'NUMBER':number,\n                    'OUTPUT': 'memory:extracted'\n                }\n                logger.info(f'Parameters: {str(parameter)}')\n                result = processing.run('native:randomextract', parameter, feedback=Worker.progress)['OUTPUT']\n                logger.info(\"randomExtract finished\")\n                return result\n            except Exception as error:\n                logger.error(\"An error occured in randomExtract\")\n                logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n                logger.critical(\"Program terminated\" )\n                sys.exit()\n\n        def difference(layer: QgsVectorLayer, overlay: QgsVectorLayer):\n            \"\"\"\n            Extracts features from the input layer that don\u2019t fall within the boundaries of the overlay layer.\n            Input layer features that partially overlap the overlay layer feature(s) are split along the \n            boundary of those feature(s.\n\n            Parameters\n            ----------\n            layer : QgsVectorLayer [vector: any]\n                Layer to extract (parts of) features from.\n\n            overlay : QgsVectorLayer [vector: any]\n                Layer containing the geometries that will be subtracted from the iniput layer geometries\n\n            Returns\n            -------\n            QgsVectorLayer [vector: polygon/line]\n                The result output from the algorithem\n            \"\"\"\n            logger.info(\"Finding differences\")\n            try:\n                parameter = {\n                    'INPUT': layer,\n                    'OVERLAY': overlay,\n                    'OUTPUT': 'memory:extracted'\n                }\n                logger.info(f'Parameters: {str(parameter)}')\n                result = processing.run('native:difference', parameter, feedback=Worker.progress)['OUTPUT']\n                logger.info(\"Difference  finished\")\n                return result\n            except Exception as error:\n                logger.error(\"An error occured in Difference\")\n                logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n                logger.critical(\"Program terminated\" )\n                sys.exit()\n\n        def reproject(layer: QgsVectorLayer, targetEPSG: int):\n            \"\"\"\n            Reprojects a vector layer in a different CRS.\n            The reprojected layer will have the same features and attributes of the input layer.\n            QGIS processing algorithem: native:reprojectlayer.\n\n            Parameters\n            ----------\n            layer : QgsVectorLayer [vector: polygon]\n                The QgsVectorLayer input for the algorithem\n\n            targetEPSG : Integer\n                The EPSG code og the target coordinate system.\n\n\n            Returns\n            -------\n            QgsVectorLayer [vector: polygon]\n                The result output from the algorithem\n            \"\"\"\n\n            logger.info(\"Running reporjector V2\")\n            if layerHasFeatures(layer):\n                logger.info(\"Processing \" + str(layer.featureCount()) +\" features\")\n            try:\n                parameter = {\n                    'INPUT': layer,\n                    'TARGET_CRS': QgsCoordinateReferenceSystem(targetEPSG),\n                    'OUTPUT': 'memory:Reprojected'\n                }\n                logger.info(f'Parameters: {str(parameter)}')\n                result = processing.run('native:reprojectlayer', parameter, feedback=Worker.progress)['OUTPUT']\n                logger.info(\"Reproject finished\")\n                return result\n            except Exception as error:\n                logger.error(\"An error occured reprojectiong layer\")\n                logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n                logger.critical(\"Program terminated\" )\n                sys.exit()\n\n        def simplify(layer: QgsVectorLayer, method: int, tolerance:int):\n                \"\"\"\n                Simplifies the geometries in a line or polygon layer. \n                It creates a new layer with the same features as the ones in the input layer, but with geometries containing a lower number of vertices.\n                QGIS processing algorithem: native:simplifygeometries.\n\n                Parameters\n                ----------\n                layer : QgsVectorLayer [vector: polygon]\n                    The QgsVectorLayer input for the algorithem\n\n                method : Integer\n                    Simplification method. One of: 0 \u2014 Distance (Douglas-Peucker), 1 \u2014 Snap to grid, 2 \u2014 Area (Visvalingam)\n\n                tolerance : Integer\n                    Threshold tolerance (in units of the layer): if the distance between two nodes is smaller than the tolerance value,\n                    the segment will be simplified and vertices will be removed.\n\n\n                Returns\n                -------\n                QgsVectorLayer [vector: polygon/line]\n                    The result output from the algorithem\n                \"\"\"\n\n                logger.info(\"Running simplify\")\n                if layerHasFeatures(layer):\n                    logger.info(\"Processing \" + str(layer.featureCount()) +\" features\")\n                try:\n                    parameter = {\n                        'INPUT': layer,\n                        'METHOD':method,\n                        'TOLERANCE':tolerance,\n                        'OUTPUT': 'memory:simplify'\n                    }\n                    logger.info(f'Parameters: {str(parameter)}')\n                    result = processing.run('native:simplifygeometries', parameter, feedback=Worker.progress)['OUTPUT']\n                    logger.info(\"Simplifygeometries finished\")\n                    return result\n                except Exception as error:\n                    logger.error(\"An error occured in simplifygeometries\")\n                    logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n                    logger.critical(\"Program terminated\" )\n                    sys.exit()\n\n        def forceRHR(layer: QgsVectorLayer):\n            \"\"\"\n            Forces polygon geometries to respect the Right-Hand-Rule, in which the area that is bounded\n            by a polygon is to the right of the boundary. \n            In particular, the exterior ring is oriented in a clockwise direction and any interior\n            rings in a counter-clockwise direction.\n            QGIS processing algorithem: native:forcerhr\n\n            Parameters\n            ----------\n            layer : QgsVectorLayer [vector: polygon]\n                The QgsVectorLayer input for the algorithem\n\n\n            Returns\n            -------\n            QgsVectorLayer [vector: polygon]\n                The result output from the algorithem\n            \"\"\"\n\n            logger.info(\"Running force right-hand rule\")\n            if layerHasFeatures(layer):\n                logger.info(\"Processing \" + str(layer.featureCount()) +\" features\")\n            try:\n                parameter = {\n                    'INPUT': layer,\n                    'OUTPUT': 'memory:forced'\n                }\n                result = processing.run('native:forcerhr', parameter, feedback=Worker.progress)['OUTPUT']\n                logger.info(\"forceRHR finished\")\n                return result\n            except Exception as error:\n                logger.error(\"An error occured in forceRHR\")\n                logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n                logger.critical(\"Program terminated\" )\n                sys.exit()\n\n        def join_by_attribute(layer1: QgsVectorLayer, layer1_field:str, layer2: QgsVectorLayer, layer2_field: str, fields_to_copy: list, method:int, discard: bool, prefix:str):\n            \"\"\"\n            Takes an input vector layer and creates a new vector layer that is an extended version of the input one, \n            with additional attributes in its attribute table.\n            The additional attributes and their values are taken from a second vector layer. An attribute is selected in each of them \n            to define the join criteria.\n            QGIS processing algorithem: native:joinattributestable.\n\n            Parameters\n            ----------\n            layer1 : QgsVectorLayer [vector: any]\n                The 1. QgsVectorLayer input for the algorithem\n\n            layer1_field : String\n                Field of the source layer to use for the join\n\n            layer2 : QgsVectorLayer [vector: any]\n                The 2. QgsVectorLayer input for the algorithem\n\n            layer2_field : String\n                Field of the source layer to use for the join\n\n            fields_to_copy : List\n                Select the specific fields you want to add. By default all the fields are added. Default []\n\n            method : Integer\n                The type of the final joined layer. One of: \n                0 \u2014 Create separate feature for each matching feature (one-to-many)\n                1 \u2014 Take attributes of the first matching feature only (one-to-one)\n\n            discard : Boolean\n                Check if you don\u2019t want to keep the features that could not be joined\n\n            prefix : String\n                Add a prefix to joined fields in order to easily identify them and avoid field name collision\n\n            Returns\n            -------\n            QgsVectorLayer [vector: polygon]\n                The result output from the algorithem\n\n            \"\"\"\n            logger.info(\"Joining features features\")\n            if layerHasFeatures(layer1):\n                logger.info(\"Processing \" + str(layer1.featureCount()) +\" features\")\n            try:\n                parameter = {\n                    'INPUT':layer1,\n                    'FIELD':layer1_field,\n                    'INPUT_2':layer2,\n                    'FIELD_2':layer2_field,\n                    'FIELDS_TO_COPY':fields_to_copy,\n                    'METHOD':method,\n                    'DISCARD_NONMATCHING':discard,\n                    'PREFIX':prefix,\n                    'OUTPUT': 'memory:joined'\n                }\n                logger.info(f'Parameters: {str(parameter)}')\n                result = processing.run('native:joinattributestable', parameter, feedback=Worker.progress)['OUTPUT']\n                logger.info(\"Joinattributestable finished\")\n                if layerHasFeatures(result):\n                    logger.info(\"Returning \" + str(result.featureCount()) +\" features\")\n                return result\n            except Exception as error:\n                logger.error(\"An error occured in joinattributestable\")\n                logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n                logger.critical(\"Program terminated\" )\n                sys.exit()\n\n        def dissolveFeatures(layer: QgsVectorLayer, fieldList: list, disjoined: bool):\n            \"\"\"\n            Takes a vector layer and combines its features into new features. \n            One or more attributes can be specified to dissolve features belonging to the same class \n            (having the same value for the specified attributes), alternatively all features can be dissolved to a single feature.\n            All output geometries will be converted to multi geometries. \n            QGIS processing algorithem: native:dissolve.\n\n            Parameters\n            ----------\n            layer : QgsVectorLayer [vector: any]\n                The QgsVectorLayer input for the algorithem\n\n            fieldList : List\n                List of fields to dissolve on. Default []\n\n            disjoined : Boolean\n                Keep disjoint features separate ? Default: False\n\n\n            Returns\n            -------\n            QgsVectorLayer [vector: polygon]\n                The result output from the algorithem\n\n            \"\"\"\n            logger.info(\"Dissolving features\")\n            if layerHasFeatures(layer):\n                logger.info(\"Processing \" + str(layer.featureCount()) +\" features\")\n            try:\n                parameter = {\n                    'INPUT': layer,\n                    'FIELD' : fieldList,\n                    'SEPARATE_DISJOINT' : False,\n                    'OUTPUT': 'memory:dissolved'\n                }\n                logger.info(f'Parameters: {str(parameter)}')\n                result = processing.run('native:dissolve', parameter, feedback=Worker.progress)['OUTPUT']\n                logger.info(\"DissolveFeatures finished\")\n                if layerHasFeatures(result):\n                    logger.info(\"Returning \" + str(result.featureCount()) +\" features\")\n                return result\n            except Exception as error:\n                logger.error(\"An error occured in dissolveFeatures\")\n                logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n                logger.critical(\"Program terminated\" )\n                sys.exit()\n\n        def bufferLayer(layer: QgsVectorLayer, distance: int, segements: int, endcapStyle: int, joinStyle: int, miterLimit: int, dissolve: bool):\n            \"\"\"\n            Computes a buffer area for all the features in an input layer, using a fixed or data defined distance.\n            It is possible to use a negative distance for polygon input layers.\n            In this case the buffer will result in a smaller polygon (setback).\n            QGIS processing algorithem: native:buffer\n\n            Parameters\n            ----------\n            layer : QgsVectorLayer [vector: any]\n                The QgsVectorLayer input for the algorithem\n\n            distance : Integer\n                The buffer distance. Default: 10.0\n\n            segements : Integer\n                Number og segments. Default: 5\n\n            endcapStyle : Enumeration\n                Controls how line endings are handled in the buffer. Default: 0 \n                (One of: 0 \u2014 Round, 1 \u2014 Flat, 2 \u2014 Square)\n\n            joinStyle : Enumeration\n                Specifies whether round, miter or beveled joins should be used when offsetting corners in a line.\n                Default: 0 (Options are: 0 \u2014 Round, 1 \u2014 Miter, 2 \u2014 Bevel)\n\n            miterLimit : Integer\n                Sets the maximum distance from the offset geometry to use when creating a mitered join as a factor of the offset distance\n                Default: 0, Minimum: 1\n\n            dissolve : Boolean\n                Dissolve the final buffer. Default: false.\n\n\n            Returns\n            -------\n            QgsVectorLayer [vector: polygon]\n                The result output from the algorithem\n            \"\"\"\n\n            logger.info(\"Creating buffer layer\")\n            if layerHasFeatures(layer):\n                logger.info(\"Processing \" + str(layer.featureCount()) +\" features\")\n            try:\n                parameter = {\n                    'INPUT': layer,\n                    'DISTANCE': distance,\n                    'SEGMENTS': segements,\n                    'END_CAP_STYLE': endcapStyle,\n                    'JOIN_STYLE': joinStyle,\n                    'MITER_LIMIT': miterLimit,\n                    'DISSOLVE': dissolve,\n                    'OUTPUT': 'memory:buffer'\n                }\n                logger.info(f'Parameters: {str(parameter)}')\n                result = processing.run('native:buffer', parameter, feedback=Worker.progress)['OUTPUT']\n                logger.info(\"BufferLayer finished\")\n                return result\n            except Exception as error:\n                logger.error(\"An error occured in BufferLayer\")\n                logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n                logger.critical(\"Program terminated\" )\n                sys.exit()\n\n        def fixGeometry(layer: QgsVectorLayer):\n            \"\"\"\n            Attempts to create a valid representation of a given invalid geometry without losing any of the input vertices.\n            Already valid geometries are returned without further intervention. Always outputs multi-geometry layer.\n            QGIS processing algorithem: native:fixgeometries\n\n            Parameters\n            ----------\n            layer : QgsVectorLayer [vector: any]\n                The QgsVectorLayer input for the algorithem\n\n\n            Returns\n            -------\n            QgsVectorLayer [vector: any]\n                The result output from the algorithem\n\n            \"\"\"\n            logger.info(\"Fixing geometries\")\n            if layerHasFeatures(layer):\n                logger.info(\"Processing \" + str(layer.featureCount()) +\" features\")\n            try:\n                parameter = {\n                    'INPUT': layer,\n                    'OUTPUT': 'memory:buffer'\n                }\n                logger.info(f'Parameters: {str(parameter)}')\n                result = processing.run('native:fixgeometries', parameter, feedback=Worker.progress)['OUTPUT']\n                logger.info(\"FixGeometry finished\")\n                return result\n            except Exception as error:\n                logger.error(\"An error occured in FixGeometry\")\n                logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n                logger.critical(\"Program terminated\" )\n                sys.exit()\n\n        def createCentroids(layer: str):\n            \"\"\"\n            Creates a new point layer, with points representing the centroids of the geometries of the input layer.\n            The centroid is a single point representing the barycenter (of all parts) of the feature, so it can be outside the feature borders. But can also be a point on each part of the feature.\n            The attributes of the points in the output layer are the same as for the original features.\n\n            Parameters\n            ----------\n            layer : QgsVectorLayer [vector: any]\n                The QgsVectorLayer input for the algorithem\n\n\n            Returns\n            -------\n            QgsVectorLayer [vector: any]\n                The result output from the algorithem\n\n            \"\"\"\n            logger.info(\"Creating centroids\")\n            if layerHasFeatures(layer):\n                logger.info(\"Processing \" + str(layer.featureCount()) +\" features\")\n            try:\n                parameter = {\n                    'INPUT': layer,\n                    'ALL_PARTS':False,\n                    'OUTPUT': 'memory:buffer'\n                }\n                logger.info(f'Parameters: {str(parameter)}')\n                result = processing.run('native:centroids', parameter, feedback=Worker.progress)['OUTPUT']\n                logger.info(\"Centroids finished\")\n                return result\n            except Exception as error:\n                logger.error(\"An error occured in createCentroids\")\n                logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n                logger.critical(\"Program terminated\" )\n                script_failed()\n\n        def randomselection(layer: QgsVectorLayer, method: int, number: int):\n            \"\"\"\n            Takes a vector layer and selects a subset of its features. No new layer is generated by this algorithm.\n            The subset is defined randomly, based on feature IDs, using a percentage or count value to define the \n            total number of features in the subset.\n\n            Parameters\n            ----------\n            layer : QgsVectorLayer [vector: any]\n                The QgsVectorLayer input for the algorithem\n\n            method : Integer\n                Random selection method. One of: 0 \u2014 Number of selected features, 1 \u2014 Percentage of selected features\n\n            number : Integer\n                Number or percentage of features to select\n\n            Returns\n            -------\n            QgsVectorLayer [vector: any]\n                The result output from the algorithem\n            \"\"\"\n            logger.info(\"Performing random selection\")\n            if layerHasFeatures(layer):\n                logger.info(\"Processing \" + str(layer.featureCount()) +\" features\")\n            try:\n                parameter = {\n                    'INPUT': layer,\n                    'METHOD':method,\n                    'NUMBER':number,\n                    'OUTPUT': 'memory:buffer'\n                }\n                logger.info(f'Parameters: {str(parameter)}')\n                result = processing.run('native:randomextract', parameter, feedback=Worker.progress)['OUTPUT']\n                if layerHasFeatures(result):\n                    logger.info(\"Returning \" + str(result.featureCount()) +\" features\")\n                logger.info(\"randomextract finished\")\n                return result\n            except Exception as error:\n                logger.error(\"An error occured in FixGeometry\")\n                logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n                logger.critical(\"Program terminated\" )\n                sys.exit()\n\n        def execute_sql(connection, databasetype, sql_expression, pgdb_name=None, driver=None):\n            \"\"\"\n            Execute an SQL query against a database. \n            This can be used to create tables, truncate, build indexes etc.\n            The database type must be specified in the 'database' parameter (one of 'Mssql' or 'Postgres')\n            The default Mssql driver is 'SQL Server' - if this needs to be overwritten, specify the parameter driver, else leave it empty.\n            SQL statments must be trippel double-quoted - prepare the statement in the QGIS sql executor tool for testing. \n\n            Parameters\n            ----------\n            connection : str\n                Name of a database connection from settings.json\n            databasetype : str\n                The database type, one of 'Mssql' or 'Postgres'.\n            sql_expression : str\n                The SQL expression to be executed. Use trippel double-quotes arraound the expression\n            pgdb_name: str\n                Name of postgres database if databasetype is  Postgres. Defaults to None.\n            driver : str\n                Defaults to None. The name of the Mssql driver, if 'SQL Server' is not working.\n\n            Returns\n            -------\n            Errorcode : int\n                Returns 0 if the SQL is executed without errors.\n\n            \"\"\"\n\n            config = get_config()\n            if databasetype in ('Postgres', 'Mssql'):\n                logger.info(f'Running SQL executor on {databasetype}' )\n            else :\n                logger.info(f'Unsupported database: {databasetype}, use one of \"Mssql\" or \"Postgres\"' )\n                logger.critical(\"Program terminated\" )\n                sys.exit()\n            try:\n                dbconnection = config['DatabaseConnections'][connection]\n                if databasetype == 'Mssql':\n                    import pyodbc \n                    if driver == \"\":\n                        mssqldriver = 'SQL Server'\n                    else :\n                        mssqldriver = 'driver'\n                    cnxn = pyodbc.connect('DRIVER={'+mssqldriver+'};Server='+dbconnection['host']+';Database='+dbconnection['databasename']+';User ID='+dbconnection['user']+';Password='+dbconnection['password'])\n                    logger.info(\"Using connection :\" + 'DRIVER={'+mssqldriver+'};Server='+dbconnection['host']+';Database='+dbconnection['databasename']+';User ID='+dbconnection['user']+';Password=xxxxxxxx')\n                    cursor = cnxn.cursor()\n                    logger.info(f'Query: {sql_expression}' )\n                    cursor.execute(sql_expression) \n                    logger.info(\"SQL executor finished\")\n                    return 0\n\n                if databasetype == 'Postgres':\n                    import psycopg2\n                    connection = psycopg2.connect(user=dbconnection['user'], password=dbconnection['password'], host=dbconnection['host'], port=dbconnection['port'], database=pgdb_name)\n                    logger.info(\"Using connection : user=\"+ dbconnection['user']+\", password=xxxxxx, host=\"+dbconnection['host']+\", port=\"+dbconnection['port']+\", database=\"+pgdb_name )\n                    cursor = connection.cursor()\n                    logger.info(f'Query: {sql_expression}' )\n                    cursor.execute(sql_expression)\n                    connection.commit()\n                    cursor.close()\n                    connection.close()\n                    logger.info(\"SQL executor finished\")\n                    return 0\n\n            except Exception as error:\n                logger.error(\"An error occured running SQL executor\")\n                logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n                logger.critical(\"Program terminated\" )\n                sys.exit()\n\n        def mergeVectorLayers(layers: list, crs: str ):\n            \"\"\"\n            Combines multiple vector layers of the same geometry type into a single one.\n            The attribute table of the resulting layer will contain the fields from all input layers. \n            If fields with the same name but different types are found then the exported field will be automatically \n            converted into a string type field. New fields storing the original layer name and source are also added.\n\n            Optionally, the destination coordinate reference system (CRS) for the merged layer can be set. If it is \n            not set, the CRS will be taken from the first input layer. All layers will be reprojected to match this CRS.\n\n            Parameters\n            ----------\n            layer : List [vector: any] [list]\n                The layers that are to be merged into a single layer. Layers should be of the same geometry type.\n\n            CRS : [crs]\n                Choose the CRS for the output layer. If not specified, the CRS of the first input layer is used.\n\n            Returns\n            -------\n            QgsVectorLayer [vector: any]\n                The result output from the algorithem\n\n            \"\"\"\n            logger.info(\"Performing mergeVectorLayers\")\n            logger.info(f'Processing {str(len(layers))} layers')\n            try:\n                parameter = {\n                    'LAYERS': layers,\n                    'CRS':crs,\n                    'OUTPUT': 'memory:buffer'\n                }\n                logger.info(f'Parameters: {str(parameter)}')\n                result = processing.run('native:mergevectorlayers', parameter, feedback=Worker.progress)['OUTPUT']\n                logger.info(\"Returning \" + str(result.featureCount()) +\" features\")\n                logger.info(\"mergeVectorLayers finished\")\n                return result\n            except Exception as error:\n                logger.error(\"An error occured in mergeVectorLayers\")\n                logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n                logger.critical(\"Program terminated\" )\n                script_failed()\n\n        def delete_geopacakge_layers(geopackage: str, layernames: list):\n            \"\"\"\n            Deletes one or more tables from a geopackage\n\n            Parameters\n            ----------\n            geopackage : str\n                The full path for the geopackage file\n            layernames : list\n                List of layernames to be deleted\n\n            \"\"\"\n            logger.info(\"Performing delete_geopacakge_layer\")\n            logger.info(f\"Deleting layers {layernames}\")\n\n            if os.path.isfile(geopackage):\n                try:\n                    for layer in layernames:\n                        logger.info(f\"Deleting layer {layer}\")\n                        parameter = {'DATABASE':'{0}|layername={1}'.format(geopackage, layer),\n                        'SQL':'drop table {0}'.format(layer)}\n                        logger.info(f'Parameters: {str(parameter)}')\n                        processing.run(\"native:spatialiteexecutesql\", parameter )\n                        logger.info(f\"Layer deleted\")\n                    logger.info(f\"Finished deleting layers\")\n\n\n                except Exception as error:\n                    logger.error(\"An error occured in delete_geopacakge_layer\")\n                    logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n                    logger.critical(\"Program terminated\" )\n                    script_failed()\n            else:    \n                pass\n\n        def assign_projection(layer: QgsVectorLayer, targetEPSG: int):\n            \"\"\"\n            Assign a new projection on a layer. The returned layer is precisely the same layer but assigned a new CRS.\n\n            Parameters\n            ----------\n            layer : QgsVectorLayer\n                The layer to be assigned a new CRS.\n\n            targetEPSG : int\n                The EPSG code og the target coordinate system.\n            \"\"\"\n            logger.info(f'Assigning CRS EPSG:{targetEPSG} to {layer.name()}')\n            try:\n                parameter = {\n                    'INPUT': layer,\n                    'CRS': QgsCoordinateReferenceSystem(targetEPSG),\n                    'OUTPUT': 'TEMPORARY_OUTPUT'\n                }\n                logger.info(f'Parameters: {str(parameter)}')\n                result = processing.run('native:assignprojection', parameter, feedback=Worker.progress)['OUTPUT']\n                logger.info('Assigning projection finished')\n                return result\n            except Exception as error:\n                logger.error(\"An error occured assigning a new crs to layer\")\n                logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n                logger.critical(\"Program terminated\" )\n                sys.exit()\n\n    class File:\n        '''\n        A Worker subclass that contains methods to work with the filesystem.\n        '''\n\n        def download_file(url, local_filename):\n            \"\"\"\n            Downloads a file from the given URL and saves it locally.\n\n            Parameters\n            ----------\n            url : str\n                The URL of the file to download\n            local_filename : str\n                The local path where the file should be saved.\n\n            Returns\n            -------\n            Boolean\n                True if download is succesful, otherwise False.\n            \"\"\"\n\n            logger.info(f'Downloading file from {url}')\n            try:\n                with requests.get(url, stream=True) as response:\n                    response.raise_for_status()\n                    with open(local_filename, 'wb') as file:\n                        for chunk in response.iter_content(chunk_size=8192):\n                            file.write(chunk)\n\n                logger.info(f'Download completed: {local_filename}')\n                return True\n\n            except Exception as error:\n                logger.error('An error occurred when downloading the file')\n                logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n                logger.critical(\"Program terminated\" )\n                script_failed()\n\n            return False\n\n        def folderTruncator(folder: str):\n            \"\"\"\n            Deletes all contents of a folder (files and directories), but not the folder it self.\n\n            Parameters\n            ----------\n            folder : str\n                Full path to the folder to be truncated\n\n            Returns\n            -------\n            None\n\n            \"\"\"\n\n            logger.info(f'Truncating folder {folder}')\n            try:\n                for root, dirs, files in os.walk(folder):\n                    for f in files:\n                        os.unlink(os.path.join(root, f))\n                    for d in dirs:\n                        shutil.rmtree(os.path.join(root, d))\n                logger.info(f'Folder {folder} truncated')\n\n                return None\n            except Exception as error:\n                logger.error(\"An error occured truncating folder\")\n                logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n                logger.critical(\"Program terminated\" )\n                script_failed()\n\n        def deleter(filepath : str):\n            \"\"\"\n            A worker that deletes a specific file.\n\n            Parameters\n            ----------\n                filepath (str): The full path to the file to delete\n\n            \"\"\"\n            logger.info(f'Deleting file {filepath}')\n            try:\n                if os.path.exists(filepath):\n                    os.remove(filepath)\n                    logger.info(f'File found and deleted')\n                else:\n                    logger.info(f'File does not exist, skipping delete.')\n\n            except Exception as error:\n                logger.error(f\"An error occured deleting file {filepath}\")\n                logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n                logger.critical(\"Program terminated\" )\n                sys.exit()\n\n        def mover(input_filepath : str, output_filepath : str):\n            \"\"\"\n            Moves a file from one location to another.\n            Can also be used for renaming.\n\n            Parameters\n            ----------\n\n                input_filepath (str): The full path to the file to move \n\n                output_filepath (str): The full path to the target file\n            \"\"\"\n            logger.info(f'Moving file {input_filepath} to {output_filepath}')\n            try:\n                if os.path.exists(input_filepath):\n                    shutil.copyfile(input_filepath, output_filepath)\n                    logger.info(f'File moved')\n                else:\n                    logger.info(f'Input file does not exist, skipping move.')\n\n            except Exception as error:\n                logger.error(f\"An error occured moving file {input_filepath}\")\n                logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n                logger.critical(\"Program terminated\" )\n                sys.exit()\n\n        def lister(input_folder : str, file_extension : str):\n            \"\"\"\n            Creates a python list of files with a specific extension, from an input location.\n            Returns the full path to the files. \n\n            Parameters\n            ----------\n\n                input_folder (str): The full path to teh input folder.\n\n                file_extension (str): The file extension to search for.\n\n            Returns\n            -------\n            List\n                A list of file paths derived from the input directory of the specified file type\n            \"\"\"\n            filelist = []\n            logger.info(f'Building filelist of {file_extension}-files from directory {input_folder}')\n            try:\n                for root, dirs, files in os.walk(input_folder):          \n                    for file in files:\n                        if file.endswith(file_extension):\n                            filelist.append(os.path.join(root, file))\n                if len(filelist) &gt; 0:\n                    logger.info(f'Filelist returning {len(filelist)} elements')\n                    return filelist\n                else:\n                    logger.info(f'Returning empty filelist for destinateion {input_folder}')\n                    return []\n            except Exception as error:\n                logger.error(f\"An error occured listing files from folder {input_folder}\")\n                logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n                logger.critical(\"Program terminated\" )\n                sys.exit()\n\n        def existence_checker(input_path : str):\n            \"\"\"\n            Checks if a specific file exists. Returns True if file exists, False if not.\n\n            Parameters\n            ----------\n\n                input_folder (str): The full path to the input folder.\n\n\n            Returns\n            -------\n            Boolean\n                True/False if file exists.\n            \"\"\"\n            logger.info(f'Checking if file {input_path} exists')\n            try:\n                if os.path.exists(input_path):\n                    logger.info(f'File exists, returning True')\n                    return True\n                else:\n                    logger.info(f'File does not exist, returning False')\n                    return False\n            except Exception as error:\n                logger.error(f\"An error occured checking if file {input_path} exists\")\n                logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n                logger.critical(\"Program terminated\" )\n                sys.exit()\n</code></pre>"},{"location":"workers/#python.engine.workers.Worker.File","title":"<code>File</code>","text":"<p>A Worker subclass that contains methods to work with the filesystem.</p> Source code in <code>python\\engine\\workers.py</code> <pre><code>class File:\n    '''\n    A Worker subclass that contains methods to work with the filesystem.\n    '''\n\n    def download_file(url, local_filename):\n        \"\"\"\n        Downloads a file from the given URL and saves it locally.\n\n        Parameters\n        ----------\n        url : str\n            The URL of the file to download\n        local_filename : str\n            The local path where the file should be saved.\n\n        Returns\n        -------\n        Boolean\n            True if download is succesful, otherwise False.\n        \"\"\"\n\n        logger.info(f'Downloading file from {url}')\n        try:\n            with requests.get(url, stream=True) as response:\n                response.raise_for_status()\n                with open(local_filename, 'wb') as file:\n                    for chunk in response.iter_content(chunk_size=8192):\n                        file.write(chunk)\n\n            logger.info(f'Download completed: {local_filename}')\n            return True\n\n        except Exception as error:\n            logger.error('An error occurred when downloading the file')\n            logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n            logger.critical(\"Program terminated\" )\n            script_failed()\n\n        return False\n\n    def folderTruncator(folder: str):\n        \"\"\"\n        Deletes all contents of a folder (files and directories), but not the folder it self.\n\n        Parameters\n        ----------\n        folder : str\n            Full path to the folder to be truncated\n\n        Returns\n        -------\n        None\n\n        \"\"\"\n\n        logger.info(f'Truncating folder {folder}')\n        try:\n            for root, dirs, files in os.walk(folder):\n                for f in files:\n                    os.unlink(os.path.join(root, f))\n                for d in dirs:\n                    shutil.rmtree(os.path.join(root, d))\n            logger.info(f'Folder {folder} truncated')\n\n            return None\n        except Exception as error:\n            logger.error(\"An error occured truncating folder\")\n            logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n            logger.critical(\"Program terminated\" )\n            script_failed()\n\n    def deleter(filepath : str):\n        \"\"\"\n        A worker that deletes a specific file.\n\n        Parameters\n        ----------\n            filepath (str): The full path to the file to delete\n\n        \"\"\"\n        logger.info(f'Deleting file {filepath}')\n        try:\n            if os.path.exists(filepath):\n                os.remove(filepath)\n                logger.info(f'File found and deleted')\n            else:\n                logger.info(f'File does not exist, skipping delete.')\n\n        except Exception as error:\n            logger.error(f\"An error occured deleting file {filepath}\")\n            logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n            logger.critical(\"Program terminated\" )\n            sys.exit()\n\n    def mover(input_filepath : str, output_filepath : str):\n        \"\"\"\n        Moves a file from one location to another.\n        Can also be used for renaming.\n\n        Parameters\n        ----------\n\n            input_filepath (str): The full path to the file to move \n\n            output_filepath (str): The full path to the target file\n        \"\"\"\n        logger.info(f'Moving file {input_filepath} to {output_filepath}')\n        try:\n            if os.path.exists(input_filepath):\n                shutil.copyfile(input_filepath, output_filepath)\n                logger.info(f'File moved')\n            else:\n                logger.info(f'Input file does not exist, skipping move.')\n\n        except Exception as error:\n            logger.error(f\"An error occured moving file {input_filepath}\")\n            logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n            logger.critical(\"Program terminated\" )\n            sys.exit()\n\n    def lister(input_folder : str, file_extension : str):\n        \"\"\"\n        Creates a python list of files with a specific extension, from an input location.\n        Returns the full path to the files. \n\n        Parameters\n        ----------\n\n            input_folder (str): The full path to teh input folder.\n\n            file_extension (str): The file extension to search for.\n\n        Returns\n        -------\n        List\n            A list of file paths derived from the input directory of the specified file type\n        \"\"\"\n        filelist = []\n        logger.info(f'Building filelist of {file_extension}-files from directory {input_folder}')\n        try:\n            for root, dirs, files in os.walk(input_folder):          \n                for file in files:\n                    if file.endswith(file_extension):\n                        filelist.append(os.path.join(root, file))\n            if len(filelist) &gt; 0:\n                logger.info(f'Filelist returning {len(filelist)} elements')\n                return filelist\n            else:\n                logger.info(f'Returning empty filelist for destinateion {input_folder}')\n                return []\n        except Exception as error:\n            logger.error(f\"An error occured listing files from folder {input_folder}\")\n            logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n            logger.critical(\"Program terminated\" )\n            sys.exit()\n\n    def existence_checker(input_path : str):\n        \"\"\"\n        Checks if a specific file exists. Returns True if file exists, False if not.\n\n        Parameters\n        ----------\n\n            input_folder (str): The full path to the input folder.\n\n\n        Returns\n        -------\n        Boolean\n            True/False if file exists.\n        \"\"\"\n        logger.info(f'Checking if file {input_path} exists')\n        try:\n            if os.path.exists(input_path):\n                logger.info(f'File exists, returning True')\n                return True\n            else:\n                logger.info(f'File does not exist, returning False')\n                return False\n        except Exception as error:\n            logger.error(f\"An error occured checking if file {input_path} exists\")\n            logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n            logger.critical(\"Program terminated\" )\n            sys.exit()\n</code></pre>"},{"location":"workers/#python.engine.workers.Worker.File.deleter","title":"<code>deleter(filepath)</code>","text":"<p>A worker that deletes a specific file.</p>"},{"location":"workers/#python.engine.workers.Worker.File.deleter--parameters","title":"Parameters","text":"<pre><code>filepath (str): The full path to the file to delete\n</code></pre> Source code in <code>python\\engine\\workers.py</code> <pre><code>def deleter(filepath : str):\n    \"\"\"\n    A worker that deletes a specific file.\n\n    Parameters\n    ----------\n        filepath (str): The full path to the file to delete\n\n    \"\"\"\n    logger.info(f'Deleting file {filepath}')\n    try:\n        if os.path.exists(filepath):\n            os.remove(filepath)\n            logger.info(f'File found and deleted')\n        else:\n            logger.info(f'File does not exist, skipping delete.')\n\n    except Exception as error:\n        logger.error(f\"An error occured deleting file {filepath}\")\n        logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n        logger.critical(\"Program terminated\" )\n        sys.exit()\n</code></pre>"},{"location":"workers/#python.engine.workers.Worker.File.download_file","title":"<code>download_file(url, local_filename)</code>","text":"<p>Downloads a file from the given URL and saves it locally.</p>"},{"location":"workers/#python.engine.workers.Worker.File.download_file--parameters","title":"Parameters","text":"<p>url : str     The URL of the file to download local_filename : str     The local path where the file should be saved.</p>"},{"location":"workers/#python.engine.workers.Worker.File.download_file--returns","title":"Returns","text":"<p>Boolean     True if download is succesful, otherwise False.</p> Source code in <code>python\\engine\\workers.py</code> <pre><code>def download_file(url, local_filename):\n    \"\"\"\n    Downloads a file from the given URL and saves it locally.\n\n    Parameters\n    ----------\n    url : str\n        The URL of the file to download\n    local_filename : str\n        The local path where the file should be saved.\n\n    Returns\n    -------\n    Boolean\n        True if download is succesful, otherwise False.\n    \"\"\"\n\n    logger.info(f'Downloading file from {url}')\n    try:\n        with requests.get(url, stream=True) as response:\n            response.raise_for_status()\n            with open(local_filename, 'wb') as file:\n                for chunk in response.iter_content(chunk_size=8192):\n                    file.write(chunk)\n\n        logger.info(f'Download completed: {local_filename}')\n        return True\n\n    except Exception as error:\n        logger.error('An error occurred when downloading the file')\n        logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n        logger.critical(\"Program terminated\" )\n        script_failed()\n\n    return False\n</code></pre>"},{"location":"workers/#python.engine.workers.Worker.File.existence_checker","title":"<code>existence_checker(input_path)</code>","text":"<p>Checks if a specific file exists. Returns True if file exists, False if not.</p>"},{"location":"workers/#python.engine.workers.Worker.File.existence_checker--parameters","title":"Parameters","text":"<pre><code>input_folder (str): The full path to the input folder.\n</code></pre>"},{"location":"workers/#python.engine.workers.Worker.File.existence_checker--returns","title":"Returns","text":"<p>Boolean     True/False if file exists.</p> Source code in <code>python\\engine\\workers.py</code> <pre><code>def existence_checker(input_path : str):\n    \"\"\"\n    Checks if a specific file exists. Returns True if file exists, False if not.\n\n    Parameters\n    ----------\n\n        input_folder (str): The full path to the input folder.\n\n\n    Returns\n    -------\n    Boolean\n        True/False if file exists.\n    \"\"\"\n    logger.info(f'Checking if file {input_path} exists')\n    try:\n        if os.path.exists(input_path):\n            logger.info(f'File exists, returning True')\n            return True\n        else:\n            logger.info(f'File does not exist, returning False')\n            return False\n    except Exception as error:\n        logger.error(f\"An error occured checking if file {input_path} exists\")\n        logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n        logger.critical(\"Program terminated\" )\n        sys.exit()\n</code></pre>"},{"location":"workers/#python.engine.workers.Worker.File.folderTruncator","title":"<code>folderTruncator(folder)</code>","text":"<p>Deletes all contents of a folder (files and directories), but not the folder it self.</p>"},{"location":"workers/#python.engine.workers.Worker.File.folderTruncator--parameters","title":"Parameters","text":"<p>folder : str     Full path to the folder to be truncated</p>"},{"location":"workers/#python.engine.workers.Worker.File.folderTruncator--returns","title":"Returns","text":"<p>None</p> Source code in <code>python\\engine\\workers.py</code> <pre><code>def folderTruncator(folder: str):\n    \"\"\"\n    Deletes all contents of a folder (files and directories), but not the folder it self.\n\n    Parameters\n    ----------\n    folder : str\n        Full path to the folder to be truncated\n\n    Returns\n    -------\n    None\n\n    \"\"\"\n\n    logger.info(f'Truncating folder {folder}')\n    try:\n        for root, dirs, files in os.walk(folder):\n            for f in files:\n                os.unlink(os.path.join(root, f))\n            for d in dirs:\n                shutil.rmtree(os.path.join(root, d))\n        logger.info(f'Folder {folder} truncated')\n\n        return None\n    except Exception as error:\n        logger.error(\"An error occured truncating folder\")\n        logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n        logger.critical(\"Program terminated\" )\n        script_failed()\n</code></pre>"},{"location":"workers/#python.engine.workers.Worker.File.lister","title":"<code>lister(input_folder, file_extension)</code>","text":"<p>Creates a python list of files with a specific extension, from an input location. Returns the full path to the files. </p>"},{"location":"workers/#python.engine.workers.Worker.File.lister--parameters","title":"Parameters","text":"<pre><code>input_folder (str): The full path to teh input folder.\n\nfile_extension (str): The file extension to search for.\n</code></pre>"},{"location":"workers/#python.engine.workers.Worker.File.lister--returns","title":"Returns","text":"<p>List     A list of file paths derived from the input directory of the specified file type</p> Source code in <code>python\\engine\\workers.py</code> <pre><code>def lister(input_folder : str, file_extension : str):\n    \"\"\"\n    Creates a python list of files with a specific extension, from an input location.\n    Returns the full path to the files. \n\n    Parameters\n    ----------\n\n        input_folder (str): The full path to teh input folder.\n\n        file_extension (str): The file extension to search for.\n\n    Returns\n    -------\n    List\n        A list of file paths derived from the input directory of the specified file type\n    \"\"\"\n    filelist = []\n    logger.info(f'Building filelist of {file_extension}-files from directory {input_folder}')\n    try:\n        for root, dirs, files in os.walk(input_folder):          \n            for file in files:\n                if file.endswith(file_extension):\n                    filelist.append(os.path.join(root, file))\n        if len(filelist) &gt; 0:\n            logger.info(f'Filelist returning {len(filelist)} elements')\n            return filelist\n        else:\n            logger.info(f'Returning empty filelist for destinateion {input_folder}')\n            return []\n    except Exception as error:\n        logger.error(f\"An error occured listing files from folder {input_folder}\")\n        logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n        logger.critical(\"Program terminated\" )\n        sys.exit()\n</code></pre>"},{"location":"workers/#python.engine.workers.Worker.File.mover","title":"<code>mover(input_filepath, output_filepath)</code>","text":"<p>Moves a file from one location to another. Can also be used for renaming.</p>"},{"location":"workers/#python.engine.workers.Worker.File.mover--parameters","title":"Parameters","text":"<pre><code>input_filepath (str): The full path to the file to move\n\noutput_filepath (str): The full path to the target file\n</code></pre> Source code in <code>python\\engine\\workers.py</code> <pre><code>def mover(input_filepath : str, output_filepath : str):\n    \"\"\"\n    Moves a file from one location to another.\n    Can also be used for renaming.\n\n    Parameters\n    ----------\n\n        input_filepath (str): The full path to the file to move \n\n        output_filepath (str): The full path to the target file\n    \"\"\"\n    logger.info(f'Moving file {input_filepath} to {output_filepath}')\n    try:\n        if os.path.exists(input_filepath):\n            shutil.copyfile(input_filepath, output_filepath)\n            logger.info(f'File moved')\n        else:\n            logger.info(f'Input file does not exist, skipping move.')\n\n    except Exception as error:\n        logger.error(f\"An error occured moving file {input_filepath}\")\n        logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n        logger.critical(\"Program terminated\" )\n        sys.exit()\n</code></pre>"},{"location":"workers/#python.engine.workers.Worker.Vector","title":"<code>Vector</code>","text":"<p>A Worker subclass that contains methods to transform vector data or their attributes.</p> Source code in <code>python\\engine\\workers.py</code> <pre><code>class Vector:\n    '''\n    A Worker subclass that contains methods to transform vector data or their attributes.\n    '''\n\n    def attributeindex(layer: QgsVectorLayer, field: str):\n        \"\"\"\n        Creates an index to speed up queries made against a field in a table.\n        Support for index creation is dependent on the layer's data provider and the field type.\n\n        Parameters\n        ----------\n        layer : QgsVectorLayer [vector: any]\n            The QgsVectorLayer input for the algorithem\n\n        field : Field\n            The field to base the index on\n\n        Returns\n        -------\n        QgsVectorLayer [vector: any]\n            The result output from the algorithem\n        \"\"\"\n        logger.info(\"Crating attribute index on \" + layer + \" on filed \" + field)\n        try:\n            parameter = {\n                'INPUT': field,\n                'FIELD': field,\n                'OUTPUT': 'memory:extracted'\n            }\n            result = processing.run('native:createattributeindex', parameter, feedback=Worker.progress)['OUTPUT']\n            logger.info(f'Parameters: {str(parameter)}')\n            logger.info(\"createattributeindex  finished\")\n            return result\n        except Exception as error:\n            logger.error(\"An error occured in createattributeindex\")\n            logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n            logger.critical(\"Program terminated\" )\n            sys.exit()\n\n    def addxyfieldstolayer(layer: QgsVectorLayer, crs: str):\n        \"\"\"\n        Adds X and Y (or latitude/longitude) fields to a point layer. The X/Y fields can be calculated in a different CRS to the layer (e.g. creating latitude/longitude fields for a layer in a projected CRS).\n\n        Parameters\n        ----------\n        layer : QgsVectorLayer\n            The input layer.\n\n        crs : str\n            Coordinate reference system to use for the generated x and y fields.\n\n        Returns\n        -------\n\n        QgsVectorLayer\n            Specify the output layer.\n        \"\"\"\n        logger.info(f\"Adding X/Y fields to {layer}\" )\n        try:\n            parameter = {\n                'INPUT': layer,\n                'CRS': crs,\n                'OUTPUT': 'memory:output_from_addxyfieldstolayer'\n            }\n            result = processing.run('native:addxyfieldstolayer', parameter, feedback=Worker.progress)['OUTPUT']\n            logger.info(f'Parameters: {str(parameter)}')\n            logger.info(\"addxyfieldstolayer  finished\")\n            return result\n        except Exception as error:\n            logger.error(\"An error occured in addxyfieldstolayer\")\n            logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n            logger.critical(\"Program terminated\" )\n            sys.exit()\n\n    def convexhull(layer: QgsVectorLayer):\n        \"\"\"\n        Calculates the convex hull for each feature in an input layer.\n\n        Parameters\n        ----------\n        layer : QgsVectorLayer\n            Input vector layer\n\n        Returns\n        -------\n        QgsVectorLayer\n            Specify the output vector layer.\n        \"\"\"\n        logger.info(f\" Calculating convexhull for layer {layer}\")\n        try:\n            parameter = {\n                'INPUT': layer,\n                'OUTPUT': 'memory:output_from_convexhull'\n            }\n            result = processing.run('native:convexhull', parameter, feedback=Worker.progress)['OUTPUT']\n            logger.info(f'Parameters: {str(parameter)}')\n            logger.info(\"convexhull  finished\")\n            return result\n        except Exception as error:\n            logger.error(\"An error occured in convexhull\")\n            logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n            logger.critical(\"Program terminated\" )\n            sys.exit()\n\n    def concavehull(inputlayer:QgsVectorLayer, alpha: float, holes: bool, multigeom: bool ):\n        \"\"\"\n        Computes the concave hull of the features from an input point layer.\n\n        Parameters\n        ----------\n        inputlayer : QgsVectorLayer [point]\n            Input point vector layer\n\n        alpha : float\n            Number from 0 (maximum concave hull) to 1 (convex hull).\n\n        holes : bool\n            Choose whether to allow holes in the final concave hull\n\n        multigeom : bool\n            Check if you want to have singlepart geometries instead of multipart ones.\n\n        Returns\n        -------\n        QgsVectorLayer [polygon]\n            Specify the output vector layer\n        \"\"\"\n        logger.info('calcualting concavehull')\n        try:\n            parameters = {\n                'INPUT': inputlayer,\n                'ALPHA' : alpha,\n                'HOLES' : holes,\n                'NO_MULTIGEOMETRY' : multigeom,\n                'OUTPUT': 'memory:output_from_concavehull'\n            }\n            logger.info(f'Parameters: {str(parameters)}')\n            result = processing.run('native:concavehull', parameters, feedback=Worker.progress)['OUTPUT']\n            logger.info('concavehull finished')\n            return result\n        except Exception as error:\n            logger.error(\"An error occured in concavehull\")\n            logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n            logger.critical(\"Program terminated\" )\n            script_failed()            \n\n    def extractvertices(inputlayer:QgsVectorLayer):\n        \"\"\"\n        Takes a vector layer and generates a point layer with points representing the vertices in the input geometries.\n        The attributes associated to each point are the same ones associated to the feature that the vertex belongs to.\n        Additional fields are added to the vertices indicating the vertex index (beginning at 0), the feature\u2019s part and its index within the part\n        (as well as its ring for polygons), distance along original geometry and bisector angle of vertex for original geometry.\n\n        Parameters\n        ----------\n        inputlayer : QgsVectorLayer\n            Input vector layer\n\n        Returns\n        -------\n        QgsVectorLayer [point]\n            Specify the output vector layer\n        \"\"\"\n        logger.info('Extracting vertices')\n        try:\n            parameters = {\n                'INPUT': inputlayer,\n                'OUTPUT': 'memory:output_from_extractvertices'\n            }\n            logger.info(f'Parameters: {str(parameters)}')\n            result = processing.run('native:extractvertices', parameters, feedback=Worker.progress)['OUTPUT']\n            logger.info('extractvertices finished')\n            return result\n        except Exception as error:\n            logger.error(\"An error occured in extractvertices\")\n            logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n            logger.critical(\"Program terminated\" )\n            script_failed()    \n\n    def multiringconstantbuffer(inputlayer:QgsVectorLayer, rings: int, distance : str):\n        \"\"\"\n        Computes multi-ring (donut) buffer for the features of the input layer, using a fixed or dynamic distance and number of rings.\n\n        Parameters\n        ----------\n        inputlayer : QgsVectorLayer\n            Input vector layer\n\n        rings : int\n            The number of rings. It can be a unique value (same number of rings for all the features) or it can be taken from features data (the number of rings depends on feature values).\n\n        distance : str\n            Distance between the rings. It can be a unique value (same distance for all the features) or it can be taken from features data (a field in the input data layer).\n\n        Returns\n        -------\n        QgsVectorLayer [polygon]\n            Specify the output polygon vector layer\n\n        \"\"\"\n        logger.info('Creating multiringconstantbuffer')\n        try:\n            dist = float(distance)\n            logger.info('Using distance value')\n        except:\n            dist = QgsProperty.fromExpression(f'\"{distance}\"')\n            logger.info('Using distance from field')\n\n        try:\n            parameters = {\n                'INPUT': inputlayer,\n                'RINGS': rings,\n                'DISTANCE': distance,\n                'OUTPUT': 'memory:output_from_multiringconstantbuffer'\n            }\n            logger.info(f'Parameters: {str(parameters)}')\n            result = processing.run('native:multiringconstantbuffer', parameters, feedback=Worker.progress)['OUTPUT']\n            logger.info('multiringconstantbuffer finished')\n            return result\n        except Exception as error:\n            logger.error(\"An error occured in multiringconstantbuffer\")\n            logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n            logger.critical(\"Program terminated\" )\n            script_failed() \n\n    def poleofinaccessibility(inputlayer:QgsVectorLayer, tolerance: int):\n        \"\"\"\n        Calculates the pole of inaccessibility for a polygon layer, which is the most distant internal point from the boundary of the surface. \n        This algorithm uses the \u2018polylabel\u2019 algorithm (Vladimir Agafonkin, 2016), which is an iterative approach guaranteed to find the true pole of inaccessibility within\n        a specified tolerance. A more precise tolerance (lower value) requires more iterations and will take longer to calculate. \n        The distance from the calculated pole to the polygon boundary will be stored as a new attribute in the output layer.\n\n        Parameters\n        ----------\n        inputlayer : QgsVectorLayer [polygon]\n            Input vector layer\n\n        tolerance : int\n            Set the tolerance for the calculation. Default 1\n\n        Returns\n        -------\n        QgsVectorLayer [point]\n            Specify the output polygon vector layer.\n        \"\"\"\n        logger.info('calcualting poleofinaccessibility')\n        try:\n            parameters = {\n                'INPUT': inputlayer,\n                'TOLERANCE' : tolerance,\n                'OUTPUT': 'memory:output_from_poleofinaccessibility'\n            }\n            logger.info(f'Parameters: {str(parameters)}')\n            result = processing.run('native:poleofinaccessibility', parameters, feedback=Worker.progress)['OUTPUT']\n            logger.info('poleofinaccessibility finished')\n            return result\n        except Exception as error:\n            logger.error(\"An error occured in poleofinaccessibility\")\n            logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n            logger.critical(\"Program terminated\" )\n            script_failed()\n\n\n    def symmetricaldifference(inputlayer: QgsVectorLayer, overlay_layer: QgsVectorLayer):\n        \"\"\"\n        Creates a layer containing features from both the input and overlay layers but with the overlapping areas between the two layers removed.\n        The attribute table of the symmetrical difference layer contains attributes and fields from both the input and overlay layers.\n\n        Parameters\n        ----------\n        inputlayer : QgsVectorLayer\n            First layer to extract (parts of) features from.\n\n        overlay_layer : QgsVectorLayer\n            Second layer to extract (parts of) features from. Ideally the geometry type should be the same as input layer.\n\n        Returns\n        -------\n        QgsVectorLayer\n            Specify the layer to contain (the parts of) the features from the input and overlay layers that do not overlap features from the other layer\n        \"\"\"\n\n        logger.info('calcualting symetrical difference')\n        try:\n            parameters = {\n                'INPUT': inputlayer,\n                'OVERLAY' : overlay_layer,\n                'OUTPUT': 'memory:output_from_symmetricaldifference'\n            }\n            logger.info(f'Parameters: {str(parameters)}')\n            result = processing.run('native:symmetricaldifference', parameters, feedback=Worker.progress)['OUTPUT']\n            logger.info('Symmetricaldifference finished')\n            return result\n        except Exception as error:\n            logger.error(\"An error occured in symmetricaldifference\")\n            logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n            logger.critical(\"Program terminated\" )\n            script_failed()\n\n    def lineintersections(inputlayer: QgsVectorLayer, split_layer: QgsVectorLayer, input_fields: list, intersect_fields: list):\n        \"\"\"\n        Splits the lines or polygons in one layer using the lines or polygon rings in another layer to define the breaking points. Intersection between geometries in both layers are considered as split points.\n        Output will contain multi geometries for split features.\n\n        Parameters\n        ----------\n        inputlayer : QgsVectorLayer\n            Input line layer.\n\n        split_layer : QgsVectorLayer\n            Layer to use to find line intersections.\n\n        input_fields : list\n            Field(s) of the input layer to keep in the output. If no fields are chosen all fields are taken.\n\n        intersect_fields : list\n            Field(s) of the intersect layer to keep in the output. If no fields are chosen all fields are taken. Duplicate field names will be appended a count suffix to avoid collision\n\n        Returns\n        -------\n        QgsVectorLayer\n            Specify the layer to contain the intersection points of the lines from the input and overlay layers.\n\n        \"\"\"\n        logger.info('Performing line intersections')\n        try:\n            parameters = {\n                'INPUT': inputlayer,\n                'INTERSECT': split_layer,\n                'INPUT_FIELDS' : input_fields, \n                'INTERSECT_FIELDS' : intersect_fields,\n                'OUTPUT': 'memory:output_from_lineintersections'\n            }\n            logger.info(f'Parameters: {str(parameters)}')\n            result = processing.run('native:lineintersections', parameters, feedback=Worker.progress)['OUTPUT']\n            logger.info('Lineintersections finished')\n            return result\n        except Exception as error:\n            logger.error(\"An error occured in Lineintersections\")\n            logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n            logger.critical(\"Program terminated\" )\n            script_failed()\n\n    def kmeansclustering(inputlayer: QgsVectorLayer, clusters: int):\n        \"\"\"\n        Calculates the 2D distance based k-means cluster number for each input feature.\n        K-means clustering aims to partition the features into k clusters in which each feature belongs to the cluster with the nearest mean. The mean point is represented by the barycenter of the clustered features.\n        If input geometries are lines or polygons, the clustering is based on the centroid of the feature.\n\n        Parameters\n        ----------\n        inputlayer : QgsVectorLayer\n            Layer to analyze\n\n        clusters : int\n            Number of clusters to create with the features\n\n        Returns\n        -------\n        QgsVectorLayer\n            Specify the output vector layer for generated the clusters.\n        \"\"\"\n\n        logger.info('Calculating clusters')\n        try:\n            parameters = {\n                'INPUT': inputlayer,\n                'CLUSTERS' : clusters,\n                'OUTPUT': 'memory:output_from_kmeansclustering'\n            }\n            logger.info(f'Parameters: {str(parameters)}')\n            result = processing.run('native:kmeansclustering', parameters, feedback=Worker.progress)['OUTPUT']\n            logger.info('Kmeansclustering finished')\n            return result\n        except Exception as error:\n            logger.error(\"An error occured in Kmeansclustering\")\n            logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n            logger.critical(\"Program terminated\" )\n            script_failed()\n\n    def dbscanclustering(inputlayer: QgsVectorLayer, min_clusters: int, max_dist: int ):\n        \"\"\"\n        Clusters point features based on a 2D implementation of Density-based spatial clustering of applications with noise (DBSCAN) algorithm.\n        The algorithm requires two parameters, a minimum cluster size, and the maximum distance allowed between clustered points.\n\n        Parameters\n        ----------\n        inputlayer : QgsVectorLayer\n            Layer to analyze\n\n        min_clusters : int\n            Minimum number of features to generate a cluster\n\n        max_dist : int\n            Distance beyond which two features can not belong to the same cluster (eps)\n\n        Returns\n        -------\n        QgsVectorLayer\n            Specify the vector layer for the result of the clustering.\n        \"\"\"\n        logger.info('Performing DBScan clustering')\n        try:\n            parameters = {\n                'INPUT': inputlayer,\n                'MIN_SIZE' : min_clusters,\n                'EPS': max_dist,\n                'OUTPUT': 'memory:output_from_dbscanclustering'\n            }\n            logger.info(f'Parameters: {str(parameters)}')\n            result = processing.run('native:dbscanclustering', parameters, feedback=Worker.progress)['OUTPUT']\n            logger.info('Dbscanclustering finished')\n            return result\n        except Exception as error:\n            logger.error(\"An error occured in Dbscanclustering\")\n            logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n            logger.critical(\"Program terminated\" )\n            script_failed()\n\n    def countpointsinpolygon(polygons: QgsVectorLayer, points: QgsVectorLayer, weight : str, fieldname: str):\n        \"\"\"\n        Takes a point and a polygon layer and counts the number of points from the point layer in each of the polygons of the polygon layer.\n        A new polygon layer is generated, with the exact same content as the input polygon layer, but containing an additional field with the points count corresponding to each polygon.\n\n        Parameters\n        ----------\n        polygons : QgsVectorLayer\n            Polygon layer whose features are associated with the count of points they contain\n\n        points : QgsVectorLayer\n            Point layer with features to count\n\n        weight : str\n            A field from the point layer. The count generated will be the sum of the weight field of the points contained by the polygon. \n            If the weight field is not numeric, the count will be 0.\n\n        fieldname : str\n            The name of the field to store the count of points\n\n        Returns\n        -------\n        QgsVectorLayer\n            Specification of the output layer.\n        \"\"\"\n        logger.info('Conducting point in polygon')\n        try:\n            if isinstance(weight, int):\n                value = weight\n            else:\n                value = 0\n\n            parameters = {\n                'POLYGONS': polygons,\n                'POINTS': points,\n                'WEIGHT': value,\n                'FIELD' : fieldname,\n                'OUTPUT': 'memory:output_from_countpointsinpolygon'\n            }\n            logger.info(f'Parameters: {str(parameters)}')\n            result = processing.run('native:Countpointsinpolygon', parameters, feedback=Worker.progress)['OUTPUT']\n            logger.info('Promote to multipart finished')\n            return result\n        except Exception as error:\n            logger.error(\"An error occured in Countpointsinpolygon\")\n            logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n            logger.critical(\"Program terminated\" )\n            script_failed()  \n\n    def promoteToMultipart(layer: QgsVectorLayer):\n        \"\"\"\n        Generates a vectorlayer in which all geometries are multipart.\n\n        Parameters\n        ----------\n        layer : QgsVectorLayer\n            The QgsVectorLayer that is used as input.\n\n        Returns\n        -------\n        QgsVectorLayer\n            The QgsVectorLayer containing multi geometries.\n        \"\"\"\n\n        logger.info('Collecting geometries')\n        try:\n            parameters = {\n                'INPUT': layer,\n                'OUTPUT': 'memory:multipart'\n            }\n            logger.info(f'Parameters: {str(parameters)}')\n            result = processing.run('native:promotetomulti', parameters, feedback=Worker.progress)['OUTPUT']\n            logger.info('Promote to multipart finished')\n            return result\n        except Exception as error:\n            logger.error(\"An error occured in promoteToMultipart\")\n            logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n            logger.critical(\"Program terminated\" )\n            script_failed()\n\n    def extractByExpression(layer: QgsVectorLayer, expression: str):\n        \"\"\"\n        Creates a vector layer from an input layer, containing only matching features.\n        The criteria for adding features to the resulting layer is based on a QGIS expression.\n\n        Parameters\n        ----------\n        layer : QgsVectorLayer\n            The QgsVectorLayer that is used as input.\n\n        expression : String\n            Expression to filter the vector layer\n\n        Returns\n        -------\n        QgsVectorLayer\n            The QgsVectorLayer output layer.\n        \"\"\"\n        logger.info(\"Extracting by expression\")\n        try:\n            parameter = {\n                'INPUT': layer,\n                'EXPRESSION': expression,\n                'OUTPUT': 'memory:extracted'\n            }\n            logger.info(f'Parameters: {str(parameter)}')\n            result = processing.run('native:extractbyexpression', parameter, feedback=Worker.progress)['OUTPUT']\n            logger.info(\"Extractbyexpression  finished\")\n            return result\n        except Exception as error:\n            logger.error(\"An error occured in extractByExpression\")\n            logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n            logger.critical(\"Program terminated\" )\n            sys.exit()\n\n    def renameTableField (layer: QgsVectorLayer, field: str, newname: str):\n        \"\"\"\n        Renames an existing field from a vector layer.  \n        The original layer is not modified. A new layer is generated where the attribute table contains the renamed field.\n        QGIS processing algorithem: native:renametablefield\n\n        Parameters\n        ----------\n        layer : QgsVectorLayer [vector: any]\n            The QgsVectorLayer input for the algorithem\n\n        field : Tablefield\n            The field that is to be renamed\n\n        newname : String\n            New name for the field\n\n\n        Returns\n        -------\n        QgsVectorLayer [vector: any]\n            The result output from the algorithem\n        \"\"\"\n        logger.info(\"Renaming field\")\n        try:\n            parameter = {\n                'INPUT': layer,\n                'FIELD': field,\n                'NEW_NAME': newname,\n                'OUTPUT': 'memory:extracted'\n            }\n            result = processing.run('native:renametablefield', parameter, feedback=Worker.progress)['OUTPUT']\n            logger.info(f'Parameters: {str(parameter)}')\n            logger.info(\"renameTableField  finished\")\n            return result\n        except Exception as error:\n            logger.error(\"An error occured in renameTableField\")\n            logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n            logger.critical(\"Program terminated\" )\n            sys.exit()\n\n    def timeStamper(layer: QgsVectorLayer, ts_fieldname: str):\n        \"\"\"\n            Create an attribute woth current timestamp on features.\n\n        Parameters\n        ----------\n        layer : QgsVectorLayer [vector: any]\n            The QgsVectorLayer input for the algorithem\n\n        ts_fieldname : String\n            The name of the new timestamp field\n\n        Returns\n        -------\n        QgsVectorLayer [vector: any]\n            The result output from the algorithem\n        \"\"\"\n        logger.info(f'Creating timestamp {ts_fieldname} using fieldCalculator')\n        newLayer = Worker.fieldCalculator(layer, ts_fieldname, 5, 0, 0, ' now() ')\n        return newLayer\n\n    def fieldCalculator (layer: QgsVectorLayer, fieldname: str, fieldtype: int, fieldlength: int, fieldprecision: int, formula: str):\n        \"\"\"\n        Scripting the field calcualtor\n        You can use all the supported expressions and functions.\n        The original layer is not modified. A new layer is generated where the attribute table contains the calucalted field\n        QGIS processing algorithem: native:fieldcalculator\n\n        Parameters\n        ----------\n        layer : QgsVectorLayer [vector: any]\n            The QgsVectorLayer input for the algorithem\n\n        fieldname : String\n            The name of the new calcualted field\n\n        fieldtype : Enumeration\n            Type of the field,  Default: 0  (0 \u2014 Float, 1 \u2014 Integer, 2 \u2014 String, 3 \u2014 Date)\n\n        fieldlength : Integer\n            Lenght of the field, Default: 10.\n\n        fieldprecision : Integer\n            Precision of the field, Default: 3.\n\n        formula : Expression\n            The expression that populates the values of the field.\n\n\n        Returns\n        -------\n        QgsVectorLayer [vector: any]\n            The result output from the algorithem\n        \"\"\"\n        logger.info(\"Calculating field\")\n        try:\n            parameter = {\n                'INPUT': layer,\n                'FIELD_NAME': fieldname,\n                'FIELD_TYPE': fieldtype,\n                'FIELD_LENGTH': fieldlength,\n                'FIELD_PRECISION': fieldprecision,\n                'FORMULA': formula,\n                'OUTPUT': 'memory:extracted'\n            }\n            result = processing.run('native:fieldcalculator', parameter, feedback=Worker.progress)['OUTPUT']\n            logger.info(f'Parameters: {str(parameter)}')\n            logger.info(\"fieldCalculator  finished\")\n            return result\n        except Exception as error:\n            logger.error(\"An error occured in fieldCalculator\")\n            logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n            logger.critical(\"Program terminated\" )\n            sys.exit()\n\n    def deleteColumns (layer: QgsVectorLayer, columns: list):\n        \"\"\"\n        Takes a vector layer and generates a new one that has the same features but without the selected columns.\n\n        Parameters\n        ----------\n        layer : QgsVectorLayer\n            Input vector layer to drop field(s) from\n\n        columns : List of tablefields\n            The field(s) to drop\n\n        Returns\n        -------\n        QgsVectorLayer\n            The QgsVectorLayer output layer.\n        \"\"\"\n        logger.info(\"deleting fields\")\n\n        try:\n            parameter = {\n                'INPUT': layer,\n                'COLUMN':columns,\n                'OUTPUT': 'memory:extracted'\n            }\n            result = processing.run('native:deletecolumn', parameter, feedback=Worker.progress)['OUTPUT']\n            logger.info(f'Parameters: {str(parameter)}')\n            logger.info(\"deleteColumns  finished\")\n            return result\n        except Exception as error:\n            logger.error(\"An error occured in deleteColumns\")\n            logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n            logger.critical(\"Program terminated\" )\n            sys.exit()\n\n    def addAutoIncrementalField(layer: QgsVectorLayer, fieldname: str, start: int):\n        \"\"\"\n        Adds a new integer field to a vector layer, with a sequential value for each feature.\n        This field can be used as a unique ID for features in the layer. The new attribute is not added to the input layer but a new layer is generated instead.\n        The initial starting value for the incremental series can be specified. Optionally, the incremental series can be based on grouping \n        fields and a sort order for features can also be specified.\n\n        Parameters\n        ----------\n        layer : QgsVectorLayer\n            The QgsVectorLayer that is used as input.\n\n        fieldname : String\n            Name of the field with autoincremental values.\n\n        start : Integer\n            Choose the initial number of the incremental count, Default: 0.\n\n        Returns\n        -------\n        QgsVectorLayer\n            The QgsVectorLayer output layer.\n        \"\"\"\n        logger.info(\"Adding incremental field\")\n        try:\n            parameter = {\n                'INPUT': layer,\n                'FIELD_NAME': fieldname,\n                'START':start,\n                'MODULUS':0,\n                'GROUP_FIELDS':[],\n                'SORT_EXPRESSION':'',\n                'SORT_ASCENDING':True,\n                'SORT_NULLS_FIRST':False,\n                'OUTPUT': 'memory:extracted'\n            }\n            result = processing.run('native:addautoincrementalfield', parameter, feedback=Worker.progress)['OUTPUT']\n            logger.info(f'Parameters: {str(parameter)}')\n            logger.info(\"addAutoIncrementalField  finished\")\n            return result\n        except Exception as error:\n            logger.error(\"An error occured in addAutoIncrementalField\")\n            logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n            logger.critical(\"Program terminated\" )\n            sys.exit()\n\n    def spatialindex(layer: QgsVectorLayer):\n        \"\"\"\n        Creates an index to speed up access to the features in a layer based on their spatial location.\n        Support for spatial index creation is dependent on the layer's data provider.\n\n        Parameters\n        ----------\n        layer : QgsVectorLayer [vector: any]\n            The QgsVectorLayer input for the algorithem\n\n        Returns\n        -------\n        QgsVectorLayer [vector: any]\n            The result output from the algorithem\n        \"\"\"\n\n        logger.info(\"Crating spatial index on \" + layer)\n        try:\n            parameter = {\n                'INPUT': layer,\n                'OUTPUT': 'memory:extracted'\n            }\n            result = processing.run('native:createspatialindex', parameter, feedback=Worker.progress)['OUTPUT']\n            logger.info(f'Parameters: {str(parameter)}')\n            logger.info(\"createspatialindex  finished\")\n            return result\n        except Exception as error:\n            logger.error(\"An error occured in createspatialindex\")\n            logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n            logger.critical(\"Program terminated\" )\n            sys.exit()\n\n    def clip(layer: QgsVectorLayer, overlay: str):\n        \"\"\"\n        Clips a vector layer using the features of an additional polygon layer.\n        Only the parts of the features in the input layer that fall within the polygons of \n        the overlay layer will be added to the resulting layer.\n\n        Parameters\n        ----------\n        layer : QgsVectorLayer [vector: any]\n            Layer containing the features to be clipped\n\n        overlay : [vector: polygon]\n            Layer containing the clipping features\n\n        Returns\n        -------\n        QgsVectorLayer [vector: any]\n            Layer to contain the features from the input layer that are inside the overlay (clipping) layer\n        \"\"\"\n        logger.info(\"Clipping layers\")\n        try:\n            parameter = {\n                'INPUT': layer,\n                'OVERLAY': overlay,\n                'OUTPUT': 'memory:extracted'\n            }\n            logger.info(f'Parameters: {str(parameter)}')\n            result = processing.run('native:clip', parameter, feedback=Worker.progress)['OUTPUT']\n            logger.info(\"Clip  finished\")\n            return result\n        except Exception as error:\n            logger.error(\"An error occured in Clip\")\n            logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n            logger.critical(\"Program terminated\" )\n            sys.exit()\n\n    def joinByLocation(layer: QgsVectorLayer, predicate: int, join: str, join_fields: list, method: int, discard_nomatching: bool, prefix: str):\n        \"\"\"\n        Takes an input vector layer and creates a new vector layer that is an extended version of\n        the input one, with additional attributes in its attribute table.\n        The additional attributes and their values are taken from a second vector layer.\n        A spatial criteria is applied to select the values from the second layer that are added to each \n        feature from the first layer.\n\n        Parameters\n        ----------\n        layer : QgsVectorLayer [vector: any]\n            Input vector layer. \n            The output layer will consist of the features of this layer with attributes from \n            matching features in the second layer.\n\n        predicate : [enumeration] Default: [0]\n            Type of spatial relation the source feature should have with the target feature so that they could be joined. One or more of:\n            0 \u2014 intersect, 1 \u2014 contain, 2 \u2014 equal, 3 \u2014 touch, 4 \u2014 overlap, 5 \u2014 are within 6 \u2014 cross.\n\n        join : [vector: any]\n            The join layer. \n            Features of this vector layer will add their attributes to the source layer attribute table if \n            they satisfy the spatial relationship.\n\n        join_fields : [tablefield: any] [list]\n            Select the specific fields you want to add from the join layer. \n            By default all the fields are added.\n\n        method : [enumeration]           \t\n            The type of the final joined layer. One of: \n            0 \u2014 Create separate feature for each matching feature (one-to-many)\n            1 \u2014 Take attributes of the first matching feature only (one-to-one)\n            2 \u2014 Take attributes of the feature with largest overlap only (one-to-one)\n\n        discard_nomatching : [boolean] Default: False\n            Remove from the output the input layer\u2019s features which could not be joined\n\n        prefix : [string]\n            Add a prefix to joined fields in order to easily identify them and avoid field name collision\n\n        Returns\n        -------\n        QgsVectorLayer [vector: any]\n            the output vector layer for the join.\n        \"\"\"\n        logger.info(\"Clipping layers\")\n        try:\n            parameter = {\n                'INPUT': layer,\n                'PREDICATE':predicate,\n                'JOIN':join,\n                'JOIN_FIELDS':join_fields,\n                'METHOD':method,\n                'DISCARD_NONMATCHING':discard_nomatching,\n                'PREFIX':prefix,\n                'OUTPUT': 'memory:extracted'\n            }\n            logger.info(f'Parameters: {str(parameter)}')\n            result = processing.run('native:joinattributesbylocation', parameter, feedback=Worker.progress)['OUTPUT']\n            logger.info(\"joinByLocation finished\")\n            return result\n        except Exception as error:\n            logger.error(\"An error occured in joinByLocation\")\n            logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n            logger.critical(\"Program terminated\" )\n            sys.exit()\n\n    def extractByLocation(layer: QgsVectorLayer, predicate: int, intersect: str):\n        \"\"\"_summary_\n\n        Parameters\n        ----------\n        layer : QgsVectorLayer [vector: any]\n            Input vector layer. \n\n        predicate : [enumeration] Default: [0]\n            Type of spatial relation the source feature should have with the target feature so that they could be joined. One or more of:\n            0 \u2014 intersect, 1 \u2014 contain, 2 \u2014 equal, 3 \u2014 touch, 4 \u2014 overlap, 5 \u2014 are within 6 \u2014 cross.\n\n        intersect : QgsVectorLayer [vector: any]\n            Intersection vector layer\n\n        Returns\n        -------\n        QgsVectorLayer [vector: any]\n            the output vector layer for the join.\n        \"\"\"\n        logger.info(\"Extracting by location\")\n        try:\n            parameter = {\n                'INPUT': layer,\n                'PREDICATE':predicate,\n                'INTERSECT':intersect,\n                'OUTPUT': 'memory:extracted'\n            }\n            logger.info(f'Parameters: {str(parameter)}')\n            result = processing.run('native:extractbylocation', parameter, feedback=Worker.progress)['OUTPUT']\n            logger.info(\"extractByLocation finished\")\n            return result\n        except Exception as error:\n            logger.error(\"An error occured in extractByLocation\")\n            logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n            logger.critical(\"Program terminated\" )\n            sys.exit()\n\n    def randomExtract(layer: QgsVectorLayer, method: int, number: int):\n        \"\"\"\n        Takes a vector layer and generates a new one that contains only a subset of the features in the input layer.\n        The subset is defined randomly, based on feature IDs, using a percentage or count value to define \n        the total number of features in the subset.\n\n        Parameters\n        ----------\n        layer : QgsVectorLayer [vector: any]\n            Input vector layer. \n\n        method : [enumeration] Default: 0\n            Random selection method. One of: 0 \u2014 Number of selected features 1 \u2014 Percentage of selected features\n\n        number : [number] Default: 10\n            Number or percentage of features to select\n\n        Returns\n        -------\n        QgsVectorLayer [vector: polygon/line]\n            The result output from the algorithem\n        \"\"\"\n        logger.info(\"Extracting random features\")\n        try:\n            parameter = {\n                'INPUT': layer,\n                'METHOD':method,\n                'NUMBER':number,\n                'OUTPUT': 'memory:extracted'\n            }\n            logger.info(f'Parameters: {str(parameter)}')\n            result = processing.run('native:randomextract', parameter, feedback=Worker.progress)['OUTPUT']\n            logger.info(\"randomExtract finished\")\n            return result\n        except Exception as error:\n            logger.error(\"An error occured in randomExtract\")\n            logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n            logger.critical(\"Program terminated\" )\n            sys.exit()\n\n    def difference(layer: QgsVectorLayer, overlay: QgsVectorLayer):\n        \"\"\"\n        Extracts features from the input layer that don\u2019t fall within the boundaries of the overlay layer.\n        Input layer features that partially overlap the overlay layer feature(s) are split along the \n        boundary of those feature(s.\n\n        Parameters\n        ----------\n        layer : QgsVectorLayer [vector: any]\n            Layer to extract (parts of) features from.\n\n        overlay : QgsVectorLayer [vector: any]\n            Layer containing the geometries that will be subtracted from the iniput layer geometries\n\n        Returns\n        -------\n        QgsVectorLayer [vector: polygon/line]\n            The result output from the algorithem\n        \"\"\"\n        logger.info(\"Finding differences\")\n        try:\n            parameter = {\n                'INPUT': layer,\n                'OVERLAY': overlay,\n                'OUTPUT': 'memory:extracted'\n            }\n            logger.info(f'Parameters: {str(parameter)}')\n            result = processing.run('native:difference', parameter, feedback=Worker.progress)['OUTPUT']\n            logger.info(\"Difference  finished\")\n            return result\n        except Exception as error:\n            logger.error(\"An error occured in Difference\")\n            logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n            logger.critical(\"Program terminated\" )\n            sys.exit()\n\n    def reproject(layer: QgsVectorLayer, targetEPSG: int):\n        \"\"\"\n        Reprojects a vector layer in a different CRS.\n        The reprojected layer will have the same features and attributes of the input layer.\n        QGIS processing algorithem: native:reprojectlayer.\n\n        Parameters\n        ----------\n        layer : QgsVectorLayer [vector: polygon]\n            The QgsVectorLayer input for the algorithem\n\n        targetEPSG : Integer\n            The EPSG code og the target coordinate system.\n\n\n        Returns\n        -------\n        QgsVectorLayer [vector: polygon]\n            The result output from the algorithem\n        \"\"\"\n\n        logger.info(\"Running reporjector V2\")\n        if layerHasFeatures(layer):\n            logger.info(\"Processing \" + str(layer.featureCount()) +\" features\")\n        try:\n            parameter = {\n                'INPUT': layer,\n                'TARGET_CRS': QgsCoordinateReferenceSystem(targetEPSG),\n                'OUTPUT': 'memory:Reprojected'\n            }\n            logger.info(f'Parameters: {str(parameter)}')\n            result = processing.run('native:reprojectlayer', parameter, feedback=Worker.progress)['OUTPUT']\n            logger.info(\"Reproject finished\")\n            return result\n        except Exception as error:\n            logger.error(\"An error occured reprojectiong layer\")\n            logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n            logger.critical(\"Program terminated\" )\n            sys.exit()\n\n    def simplify(layer: QgsVectorLayer, method: int, tolerance:int):\n            \"\"\"\n            Simplifies the geometries in a line or polygon layer. \n            It creates a new layer with the same features as the ones in the input layer, but with geometries containing a lower number of vertices.\n            QGIS processing algorithem: native:simplifygeometries.\n\n            Parameters\n            ----------\n            layer : QgsVectorLayer [vector: polygon]\n                The QgsVectorLayer input for the algorithem\n\n            method : Integer\n                Simplification method. One of: 0 \u2014 Distance (Douglas-Peucker), 1 \u2014 Snap to grid, 2 \u2014 Area (Visvalingam)\n\n            tolerance : Integer\n                Threshold tolerance (in units of the layer): if the distance between two nodes is smaller than the tolerance value,\n                the segment will be simplified and vertices will be removed.\n\n\n            Returns\n            -------\n            QgsVectorLayer [vector: polygon/line]\n                The result output from the algorithem\n            \"\"\"\n\n            logger.info(\"Running simplify\")\n            if layerHasFeatures(layer):\n                logger.info(\"Processing \" + str(layer.featureCount()) +\" features\")\n            try:\n                parameter = {\n                    'INPUT': layer,\n                    'METHOD':method,\n                    'TOLERANCE':tolerance,\n                    'OUTPUT': 'memory:simplify'\n                }\n                logger.info(f'Parameters: {str(parameter)}')\n                result = processing.run('native:simplifygeometries', parameter, feedback=Worker.progress)['OUTPUT']\n                logger.info(\"Simplifygeometries finished\")\n                return result\n            except Exception as error:\n                logger.error(\"An error occured in simplifygeometries\")\n                logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n                logger.critical(\"Program terminated\" )\n                sys.exit()\n\n    def forceRHR(layer: QgsVectorLayer):\n        \"\"\"\n        Forces polygon geometries to respect the Right-Hand-Rule, in which the area that is bounded\n        by a polygon is to the right of the boundary. \n        In particular, the exterior ring is oriented in a clockwise direction and any interior\n        rings in a counter-clockwise direction.\n        QGIS processing algorithem: native:forcerhr\n\n        Parameters\n        ----------\n        layer : QgsVectorLayer [vector: polygon]\n            The QgsVectorLayer input for the algorithem\n\n\n        Returns\n        -------\n        QgsVectorLayer [vector: polygon]\n            The result output from the algorithem\n        \"\"\"\n\n        logger.info(\"Running force right-hand rule\")\n        if layerHasFeatures(layer):\n            logger.info(\"Processing \" + str(layer.featureCount()) +\" features\")\n        try:\n            parameter = {\n                'INPUT': layer,\n                'OUTPUT': 'memory:forced'\n            }\n            result = processing.run('native:forcerhr', parameter, feedback=Worker.progress)['OUTPUT']\n            logger.info(\"forceRHR finished\")\n            return result\n        except Exception as error:\n            logger.error(\"An error occured in forceRHR\")\n            logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n            logger.critical(\"Program terminated\" )\n            sys.exit()\n\n    def join_by_attribute(layer1: QgsVectorLayer, layer1_field:str, layer2: QgsVectorLayer, layer2_field: str, fields_to_copy: list, method:int, discard: bool, prefix:str):\n        \"\"\"\n        Takes an input vector layer and creates a new vector layer that is an extended version of the input one, \n        with additional attributes in its attribute table.\n        The additional attributes and their values are taken from a second vector layer. An attribute is selected in each of them \n        to define the join criteria.\n        QGIS processing algorithem: native:joinattributestable.\n\n        Parameters\n        ----------\n        layer1 : QgsVectorLayer [vector: any]\n            The 1. QgsVectorLayer input for the algorithem\n\n        layer1_field : String\n            Field of the source layer to use for the join\n\n        layer2 : QgsVectorLayer [vector: any]\n            The 2. QgsVectorLayer input for the algorithem\n\n        layer2_field : String\n            Field of the source layer to use for the join\n\n        fields_to_copy : List\n            Select the specific fields you want to add. By default all the fields are added. Default []\n\n        method : Integer\n            The type of the final joined layer. One of: \n            0 \u2014 Create separate feature for each matching feature (one-to-many)\n            1 \u2014 Take attributes of the first matching feature only (one-to-one)\n\n        discard : Boolean\n            Check if you don\u2019t want to keep the features that could not be joined\n\n        prefix : String\n            Add a prefix to joined fields in order to easily identify them and avoid field name collision\n\n        Returns\n        -------\n        QgsVectorLayer [vector: polygon]\n            The result output from the algorithem\n\n        \"\"\"\n        logger.info(\"Joining features features\")\n        if layerHasFeatures(layer1):\n            logger.info(\"Processing \" + str(layer1.featureCount()) +\" features\")\n        try:\n            parameter = {\n                'INPUT':layer1,\n                'FIELD':layer1_field,\n                'INPUT_2':layer2,\n                'FIELD_2':layer2_field,\n                'FIELDS_TO_COPY':fields_to_copy,\n                'METHOD':method,\n                'DISCARD_NONMATCHING':discard,\n                'PREFIX':prefix,\n                'OUTPUT': 'memory:joined'\n            }\n            logger.info(f'Parameters: {str(parameter)}')\n            result = processing.run('native:joinattributestable', parameter, feedback=Worker.progress)['OUTPUT']\n            logger.info(\"Joinattributestable finished\")\n            if layerHasFeatures(result):\n                logger.info(\"Returning \" + str(result.featureCount()) +\" features\")\n            return result\n        except Exception as error:\n            logger.error(\"An error occured in joinattributestable\")\n            logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n            logger.critical(\"Program terminated\" )\n            sys.exit()\n\n    def dissolveFeatures(layer: QgsVectorLayer, fieldList: list, disjoined: bool):\n        \"\"\"\n        Takes a vector layer and combines its features into new features. \n        One or more attributes can be specified to dissolve features belonging to the same class \n        (having the same value for the specified attributes), alternatively all features can be dissolved to a single feature.\n        All output geometries will be converted to multi geometries. \n        QGIS processing algorithem: native:dissolve.\n\n        Parameters\n        ----------\n        layer : QgsVectorLayer [vector: any]\n            The QgsVectorLayer input for the algorithem\n\n        fieldList : List\n            List of fields to dissolve on. Default []\n\n        disjoined : Boolean\n            Keep disjoint features separate ? Default: False\n\n\n        Returns\n        -------\n        QgsVectorLayer [vector: polygon]\n            The result output from the algorithem\n\n        \"\"\"\n        logger.info(\"Dissolving features\")\n        if layerHasFeatures(layer):\n            logger.info(\"Processing \" + str(layer.featureCount()) +\" features\")\n        try:\n            parameter = {\n                'INPUT': layer,\n                'FIELD' : fieldList,\n                'SEPARATE_DISJOINT' : False,\n                'OUTPUT': 'memory:dissolved'\n            }\n            logger.info(f'Parameters: {str(parameter)}')\n            result = processing.run('native:dissolve', parameter, feedback=Worker.progress)['OUTPUT']\n            logger.info(\"DissolveFeatures finished\")\n            if layerHasFeatures(result):\n                logger.info(\"Returning \" + str(result.featureCount()) +\" features\")\n            return result\n        except Exception as error:\n            logger.error(\"An error occured in dissolveFeatures\")\n            logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n            logger.critical(\"Program terminated\" )\n            sys.exit()\n\n    def bufferLayer(layer: QgsVectorLayer, distance: int, segements: int, endcapStyle: int, joinStyle: int, miterLimit: int, dissolve: bool):\n        \"\"\"\n        Computes a buffer area for all the features in an input layer, using a fixed or data defined distance.\n        It is possible to use a negative distance for polygon input layers.\n        In this case the buffer will result in a smaller polygon (setback).\n        QGIS processing algorithem: native:buffer\n\n        Parameters\n        ----------\n        layer : QgsVectorLayer [vector: any]\n            The QgsVectorLayer input for the algorithem\n\n        distance : Integer\n            The buffer distance. Default: 10.0\n\n        segements : Integer\n            Number og segments. Default: 5\n\n        endcapStyle : Enumeration\n            Controls how line endings are handled in the buffer. Default: 0 \n            (One of: 0 \u2014 Round, 1 \u2014 Flat, 2 \u2014 Square)\n\n        joinStyle : Enumeration\n            Specifies whether round, miter or beveled joins should be used when offsetting corners in a line.\n            Default: 0 (Options are: 0 \u2014 Round, 1 \u2014 Miter, 2 \u2014 Bevel)\n\n        miterLimit : Integer\n            Sets the maximum distance from the offset geometry to use when creating a mitered join as a factor of the offset distance\n            Default: 0, Minimum: 1\n\n        dissolve : Boolean\n            Dissolve the final buffer. Default: false.\n\n\n        Returns\n        -------\n        QgsVectorLayer [vector: polygon]\n            The result output from the algorithem\n        \"\"\"\n\n        logger.info(\"Creating buffer layer\")\n        if layerHasFeatures(layer):\n            logger.info(\"Processing \" + str(layer.featureCount()) +\" features\")\n        try:\n            parameter = {\n                'INPUT': layer,\n                'DISTANCE': distance,\n                'SEGMENTS': segements,\n                'END_CAP_STYLE': endcapStyle,\n                'JOIN_STYLE': joinStyle,\n                'MITER_LIMIT': miterLimit,\n                'DISSOLVE': dissolve,\n                'OUTPUT': 'memory:buffer'\n            }\n            logger.info(f'Parameters: {str(parameter)}')\n            result = processing.run('native:buffer', parameter, feedback=Worker.progress)['OUTPUT']\n            logger.info(\"BufferLayer finished\")\n            return result\n        except Exception as error:\n            logger.error(\"An error occured in BufferLayer\")\n            logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n            logger.critical(\"Program terminated\" )\n            sys.exit()\n\n    def fixGeometry(layer: QgsVectorLayer):\n        \"\"\"\n        Attempts to create a valid representation of a given invalid geometry without losing any of the input vertices.\n        Already valid geometries are returned without further intervention. Always outputs multi-geometry layer.\n        QGIS processing algorithem: native:fixgeometries\n\n        Parameters\n        ----------\n        layer : QgsVectorLayer [vector: any]\n            The QgsVectorLayer input for the algorithem\n\n\n        Returns\n        -------\n        QgsVectorLayer [vector: any]\n            The result output from the algorithem\n\n        \"\"\"\n        logger.info(\"Fixing geometries\")\n        if layerHasFeatures(layer):\n            logger.info(\"Processing \" + str(layer.featureCount()) +\" features\")\n        try:\n            parameter = {\n                'INPUT': layer,\n                'OUTPUT': 'memory:buffer'\n            }\n            logger.info(f'Parameters: {str(parameter)}')\n            result = processing.run('native:fixgeometries', parameter, feedback=Worker.progress)['OUTPUT']\n            logger.info(\"FixGeometry finished\")\n            return result\n        except Exception as error:\n            logger.error(\"An error occured in FixGeometry\")\n            logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n            logger.critical(\"Program terminated\" )\n            sys.exit()\n\n    def createCentroids(layer: str):\n        \"\"\"\n        Creates a new point layer, with points representing the centroids of the geometries of the input layer.\n        The centroid is a single point representing the barycenter (of all parts) of the feature, so it can be outside the feature borders. But can also be a point on each part of the feature.\n        The attributes of the points in the output layer are the same as for the original features.\n\n        Parameters\n        ----------\n        layer : QgsVectorLayer [vector: any]\n            The QgsVectorLayer input for the algorithem\n\n\n        Returns\n        -------\n        QgsVectorLayer [vector: any]\n            The result output from the algorithem\n\n        \"\"\"\n        logger.info(\"Creating centroids\")\n        if layerHasFeatures(layer):\n            logger.info(\"Processing \" + str(layer.featureCount()) +\" features\")\n        try:\n            parameter = {\n                'INPUT': layer,\n                'ALL_PARTS':False,\n                'OUTPUT': 'memory:buffer'\n            }\n            logger.info(f'Parameters: {str(parameter)}')\n            result = processing.run('native:centroids', parameter, feedback=Worker.progress)['OUTPUT']\n            logger.info(\"Centroids finished\")\n            return result\n        except Exception as error:\n            logger.error(\"An error occured in createCentroids\")\n            logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n            logger.critical(\"Program terminated\" )\n            script_failed()\n\n    def randomselection(layer: QgsVectorLayer, method: int, number: int):\n        \"\"\"\n        Takes a vector layer and selects a subset of its features. No new layer is generated by this algorithm.\n        The subset is defined randomly, based on feature IDs, using a percentage or count value to define the \n        total number of features in the subset.\n\n        Parameters\n        ----------\n        layer : QgsVectorLayer [vector: any]\n            The QgsVectorLayer input for the algorithem\n\n        method : Integer\n            Random selection method. One of: 0 \u2014 Number of selected features, 1 \u2014 Percentage of selected features\n\n        number : Integer\n            Number or percentage of features to select\n\n        Returns\n        -------\n        QgsVectorLayer [vector: any]\n            The result output from the algorithem\n        \"\"\"\n        logger.info(\"Performing random selection\")\n        if layerHasFeatures(layer):\n            logger.info(\"Processing \" + str(layer.featureCount()) +\" features\")\n        try:\n            parameter = {\n                'INPUT': layer,\n                'METHOD':method,\n                'NUMBER':number,\n                'OUTPUT': 'memory:buffer'\n            }\n            logger.info(f'Parameters: {str(parameter)}')\n            result = processing.run('native:randomextract', parameter, feedback=Worker.progress)['OUTPUT']\n            if layerHasFeatures(result):\n                logger.info(\"Returning \" + str(result.featureCount()) +\" features\")\n            logger.info(\"randomextract finished\")\n            return result\n        except Exception as error:\n            logger.error(\"An error occured in FixGeometry\")\n            logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n            logger.critical(\"Program terminated\" )\n            sys.exit()\n\n    def execute_sql(connection, databasetype, sql_expression, pgdb_name=None, driver=None):\n        \"\"\"\n        Execute an SQL query against a database. \n        This can be used to create tables, truncate, build indexes etc.\n        The database type must be specified in the 'database' parameter (one of 'Mssql' or 'Postgres')\n        The default Mssql driver is 'SQL Server' - if this needs to be overwritten, specify the parameter driver, else leave it empty.\n        SQL statments must be trippel double-quoted - prepare the statement in the QGIS sql executor tool for testing. \n\n        Parameters\n        ----------\n        connection : str\n            Name of a database connection from settings.json\n        databasetype : str\n            The database type, one of 'Mssql' or 'Postgres'.\n        sql_expression : str\n            The SQL expression to be executed. Use trippel double-quotes arraound the expression\n        pgdb_name: str\n            Name of postgres database if databasetype is  Postgres. Defaults to None.\n        driver : str\n            Defaults to None. The name of the Mssql driver, if 'SQL Server' is not working.\n\n        Returns\n        -------\n        Errorcode : int\n            Returns 0 if the SQL is executed without errors.\n\n        \"\"\"\n\n        config = get_config()\n        if databasetype in ('Postgres', 'Mssql'):\n            logger.info(f'Running SQL executor on {databasetype}' )\n        else :\n            logger.info(f'Unsupported database: {databasetype}, use one of \"Mssql\" or \"Postgres\"' )\n            logger.critical(\"Program terminated\" )\n            sys.exit()\n        try:\n            dbconnection = config['DatabaseConnections'][connection]\n            if databasetype == 'Mssql':\n                import pyodbc \n                if driver == \"\":\n                    mssqldriver = 'SQL Server'\n                else :\n                    mssqldriver = 'driver'\n                cnxn = pyodbc.connect('DRIVER={'+mssqldriver+'};Server='+dbconnection['host']+';Database='+dbconnection['databasename']+';User ID='+dbconnection['user']+';Password='+dbconnection['password'])\n                logger.info(\"Using connection :\" + 'DRIVER={'+mssqldriver+'};Server='+dbconnection['host']+';Database='+dbconnection['databasename']+';User ID='+dbconnection['user']+';Password=xxxxxxxx')\n                cursor = cnxn.cursor()\n                logger.info(f'Query: {sql_expression}' )\n                cursor.execute(sql_expression) \n                logger.info(\"SQL executor finished\")\n                return 0\n\n            if databasetype == 'Postgres':\n                import psycopg2\n                connection = psycopg2.connect(user=dbconnection['user'], password=dbconnection['password'], host=dbconnection['host'], port=dbconnection['port'], database=pgdb_name)\n                logger.info(\"Using connection : user=\"+ dbconnection['user']+\", password=xxxxxx, host=\"+dbconnection['host']+\", port=\"+dbconnection['port']+\", database=\"+pgdb_name )\n                cursor = connection.cursor()\n                logger.info(f'Query: {sql_expression}' )\n                cursor.execute(sql_expression)\n                connection.commit()\n                cursor.close()\n                connection.close()\n                logger.info(\"SQL executor finished\")\n                return 0\n\n        except Exception as error:\n            logger.error(\"An error occured running SQL executor\")\n            logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n            logger.critical(\"Program terminated\" )\n            sys.exit()\n\n    def mergeVectorLayers(layers: list, crs: str ):\n        \"\"\"\n        Combines multiple vector layers of the same geometry type into a single one.\n        The attribute table of the resulting layer will contain the fields from all input layers. \n        If fields with the same name but different types are found then the exported field will be automatically \n        converted into a string type field. New fields storing the original layer name and source are also added.\n\n        Optionally, the destination coordinate reference system (CRS) for the merged layer can be set. If it is \n        not set, the CRS will be taken from the first input layer. All layers will be reprojected to match this CRS.\n\n        Parameters\n        ----------\n        layer : List [vector: any] [list]\n            The layers that are to be merged into a single layer. Layers should be of the same geometry type.\n\n        CRS : [crs]\n            Choose the CRS for the output layer. If not specified, the CRS of the first input layer is used.\n\n        Returns\n        -------\n        QgsVectorLayer [vector: any]\n            The result output from the algorithem\n\n        \"\"\"\n        logger.info(\"Performing mergeVectorLayers\")\n        logger.info(f'Processing {str(len(layers))} layers')\n        try:\n            parameter = {\n                'LAYERS': layers,\n                'CRS':crs,\n                'OUTPUT': 'memory:buffer'\n            }\n            logger.info(f'Parameters: {str(parameter)}')\n            result = processing.run('native:mergevectorlayers', parameter, feedback=Worker.progress)['OUTPUT']\n            logger.info(\"Returning \" + str(result.featureCount()) +\" features\")\n            logger.info(\"mergeVectorLayers finished\")\n            return result\n        except Exception as error:\n            logger.error(\"An error occured in mergeVectorLayers\")\n            logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n            logger.critical(\"Program terminated\" )\n            script_failed()\n\n    def delete_geopacakge_layers(geopackage: str, layernames: list):\n        \"\"\"\n        Deletes one or more tables from a geopackage\n\n        Parameters\n        ----------\n        geopackage : str\n            The full path for the geopackage file\n        layernames : list\n            List of layernames to be deleted\n\n        \"\"\"\n        logger.info(\"Performing delete_geopacakge_layer\")\n        logger.info(f\"Deleting layers {layernames}\")\n\n        if os.path.isfile(geopackage):\n            try:\n                for layer in layernames:\n                    logger.info(f\"Deleting layer {layer}\")\n                    parameter = {'DATABASE':'{0}|layername={1}'.format(geopackage, layer),\n                    'SQL':'drop table {0}'.format(layer)}\n                    logger.info(f'Parameters: {str(parameter)}')\n                    processing.run(\"native:spatialiteexecutesql\", parameter )\n                    logger.info(f\"Layer deleted\")\n                logger.info(f\"Finished deleting layers\")\n\n\n            except Exception as error:\n                logger.error(\"An error occured in delete_geopacakge_layer\")\n                logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n                logger.critical(\"Program terminated\" )\n                script_failed()\n        else:    \n            pass\n\n    def assign_projection(layer: QgsVectorLayer, targetEPSG: int):\n        \"\"\"\n        Assign a new projection on a layer. The returned layer is precisely the same layer but assigned a new CRS.\n\n        Parameters\n        ----------\n        layer : QgsVectorLayer\n            The layer to be assigned a new CRS.\n\n        targetEPSG : int\n            The EPSG code og the target coordinate system.\n        \"\"\"\n        logger.info(f'Assigning CRS EPSG:{targetEPSG} to {layer.name()}')\n        try:\n            parameter = {\n                'INPUT': layer,\n                'CRS': QgsCoordinateReferenceSystem(targetEPSG),\n                'OUTPUT': 'TEMPORARY_OUTPUT'\n            }\n            logger.info(f'Parameters: {str(parameter)}')\n            result = processing.run('native:assignprojection', parameter, feedback=Worker.progress)['OUTPUT']\n            logger.info('Assigning projection finished')\n            return result\n        except Exception as error:\n            logger.error(\"An error occured assigning a new crs to layer\")\n            logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n            logger.critical(\"Program terminated\" )\n            sys.exit()\n</code></pre>"},{"location":"workers/#python.engine.workers.Worker.Vector.addAutoIncrementalField","title":"<code>addAutoIncrementalField(layer, fieldname, start)</code>","text":"<p>Adds a new integer field to a vector layer, with a sequential value for each feature. This field can be used as a unique ID for features in the layer. The new attribute is not added to the input layer but a new layer is generated instead. The initial starting value for the incremental series can be specified. Optionally, the incremental series can be based on grouping  fields and a sort order for features can also be specified.</p>"},{"location":"workers/#python.engine.workers.Worker.Vector.addAutoIncrementalField--parameters","title":"Parameters","text":"<p>layer : QgsVectorLayer     The QgsVectorLayer that is used as input.</p> String <p>Name of the field with autoincremental values.</p> Integer <p>Choose the initial number of the incremental count, Default: 0.</p>"},{"location":"workers/#python.engine.workers.Worker.Vector.addAutoIncrementalField--returns","title":"Returns","text":"<p>QgsVectorLayer     The QgsVectorLayer output layer.</p> Source code in <code>python\\engine\\workers.py</code> <pre><code>def addAutoIncrementalField(layer: QgsVectorLayer, fieldname: str, start: int):\n    \"\"\"\n    Adds a new integer field to a vector layer, with a sequential value for each feature.\n    This field can be used as a unique ID for features in the layer. The new attribute is not added to the input layer but a new layer is generated instead.\n    The initial starting value for the incremental series can be specified. Optionally, the incremental series can be based on grouping \n    fields and a sort order for features can also be specified.\n\n    Parameters\n    ----------\n    layer : QgsVectorLayer\n        The QgsVectorLayer that is used as input.\n\n    fieldname : String\n        Name of the field with autoincremental values.\n\n    start : Integer\n        Choose the initial number of the incremental count, Default: 0.\n\n    Returns\n    -------\n    QgsVectorLayer\n        The QgsVectorLayer output layer.\n    \"\"\"\n    logger.info(\"Adding incremental field\")\n    try:\n        parameter = {\n            'INPUT': layer,\n            'FIELD_NAME': fieldname,\n            'START':start,\n            'MODULUS':0,\n            'GROUP_FIELDS':[],\n            'SORT_EXPRESSION':'',\n            'SORT_ASCENDING':True,\n            'SORT_NULLS_FIRST':False,\n            'OUTPUT': 'memory:extracted'\n        }\n        result = processing.run('native:addautoincrementalfield', parameter, feedback=Worker.progress)['OUTPUT']\n        logger.info(f'Parameters: {str(parameter)}')\n        logger.info(\"addAutoIncrementalField  finished\")\n        return result\n    except Exception as error:\n        logger.error(\"An error occured in addAutoIncrementalField\")\n        logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n        logger.critical(\"Program terminated\" )\n        sys.exit()\n</code></pre>"},{"location":"workers/#python.engine.workers.Worker.Vector.addxyfieldstolayer","title":"<code>addxyfieldstolayer(layer, crs)</code>","text":"<p>Adds X and Y (or latitude/longitude) fields to a point layer. The X/Y fields can be calculated in a different CRS to the layer (e.g. creating latitude/longitude fields for a layer in a projected CRS).</p>"},{"location":"workers/#python.engine.workers.Worker.Vector.addxyfieldstolayer--parameters","title":"Parameters","text":"<p>layer : QgsVectorLayer     The input layer.</p> str <p>Coordinate reference system to use for the generated x and y fields.</p>"},{"location":"workers/#python.engine.workers.Worker.Vector.addxyfieldstolayer--returns","title":"Returns","text":"<p>QgsVectorLayer     Specify the output layer.</p> Source code in <code>python\\engine\\workers.py</code> <pre><code>def addxyfieldstolayer(layer: QgsVectorLayer, crs: str):\n    \"\"\"\n    Adds X and Y (or latitude/longitude) fields to a point layer. The X/Y fields can be calculated in a different CRS to the layer (e.g. creating latitude/longitude fields for a layer in a projected CRS).\n\n    Parameters\n    ----------\n    layer : QgsVectorLayer\n        The input layer.\n\n    crs : str\n        Coordinate reference system to use for the generated x and y fields.\n\n    Returns\n    -------\n\n    QgsVectorLayer\n        Specify the output layer.\n    \"\"\"\n    logger.info(f\"Adding X/Y fields to {layer}\" )\n    try:\n        parameter = {\n            'INPUT': layer,\n            'CRS': crs,\n            'OUTPUT': 'memory:output_from_addxyfieldstolayer'\n        }\n        result = processing.run('native:addxyfieldstolayer', parameter, feedback=Worker.progress)['OUTPUT']\n        logger.info(f'Parameters: {str(parameter)}')\n        logger.info(\"addxyfieldstolayer  finished\")\n        return result\n    except Exception as error:\n        logger.error(\"An error occured in addxyfieldstolayer\")\n        logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n        logger.critical(\"Program terminated\" )\n        sys.exit()\n</code></pre>"},{"location":"workers/#python.engine.workers.Worker.Vector.assign_projection","title":"<code>assign_projection(layer, targetEPSG)</code>","text":"<p>Assign a new projection on a layer. The returned layer is precisely the same layer but assigned a new CRS.</p>"},{"location":"workers/#python.engine.workers.Worker.Vector.assign_projection--parameters","title":"Parameters","text":"<p>layer : QgsVectorLayer     The layer to be assigned a new CRS.</p> int <p>The EPSG code og the target coordinate system.</p> Source code in <code>python\\engine\\workers.py</code> <pre><code>def assign_projection(layer: QgsVectorLayer, targetEPSG: int):\n    \"\"\"\n    Assign a new projection on a layer. The returned layer is precisely the same layer but assigned a new CRS.\n\n    Parameters\n    ----------\n    layer : QgsVectorLayer\n        The layer to be assigned a new CRS.\n\n    targetEPSG : int\n        The EPSG code og the target coordinate system.\n    \"\"\"\n    logger.info(f'Assigning CRS EPSG:{targetEPSG} to {layer.name()}')\n    try:\n        parameter = {\n            'INPUT': layer,\n            'CRS': QgsCoordinateReferenceSystem(targetEPSG),\n            'OUTPUT': 'TEMPORARY_OUTPUT'\n        }\n        logger.info(f'Parameters: {str(parameter)}')\n        result = processing.run('native:assignprojection', parameter, feedback=Worker.progress)['OUTPUT']\n        logger.info('Assigning projection finished')\n        return result\n    except Exception as error:\n        logger.error(\"An error occured assigning a new crs to layer\")\n        logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n        logger.critical(\"Program terminated\" )\n        sys.exit()\n</code></pre>"},{"location":"workers/#python.engine.workers.Worker.Vector.attributeindex","title":"<code>attributeindex(layer, field)</code>","text":"<p>Creates an index to speed up queries made against a field in a table. Support for index creation is dependent on the layer's data provider and the field type.</p>"},{"location":"workers/#python.engine.workers.Worker.Vector.attributeindex--parameters","title":"Parameters","text":"<p>layer : QgsVectorLayer [vector: any]     The QgsVectorLayer input for the algorithem</p> Field <p>The field to base the index on</p>"},{"location":"workers/#python.engine.workers.Worker.Vector.attributeindex--returns","title":"Returns","text":"<p>QgsVectorLayer [vector: any]     The result output from the algorithem</p> Source code in <code>python\\engine\\workers.py</code> <pre><code>def attributeindex(layer: QgsVectorLayer, field: str):\n    \"\"\"\n    Creates an index to speed up queries made against a field in a table.\n    Support for index creation is dependent on the layer's data provider and the field type.\n\n    Parameters\n    ----------\n    layer : QgsVectorLayer [vector: any]\n        The QgsVectorLayer input for the algorithem\n\n    field : Field\n        The field to base the index on\n\n    Returns\n    -------\n    QgsVectorLayer [vector: any]\n        The result output from the algorithem\n    \"\"\"\n    logger.info(\"Crating attribute index on \" + layer + \" on filed \" + field)\n    try:\n        parameter = {\n            'INPUT': field,\n            'FIELD': field,\n            'OUTPUT': 'memory:extracted'\n        }\n        result = processing.run('native:createattributeindex', parameter, feedback=Worker.progress)['OUTPUT']\n        logger.info(f'Parameters: {str(parameter)}')\n        logger.info(\"createattributeindex  finished\")\n        return result\n    except Exception as error:\n        logger.error(\"An error occured in createattributeindex\")\n        logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n        logger.critical(\"Program terminated\" )\n        sys.exit()\n</code></pre>"},{"location":"workers/#python.engine.workers.Worker.Vector.bufferLayer","title":"<code>bufferLayer(layer, distance, segements, endcapStyle, joinStyle, miterLimit, dissolve)</code>","text":"<p>Computes a buffer area for all the features in an input layer, using a fixed or data defined distance. It is possible to use a negative distance for polygon input layers. In this case the buffer will result in a smaller polygon (setback). QGIS processing algorithem: native:buffer</p>"},{"location":"workers/#python.engine.workers.Worker.Vector.bufferLayer--parameters","title":"Parameters","text":"<p>layer : QgsVectorLayer [vector: any]     The QgsVectorLayer input for the algorithem</p> Integer <p>The buffer distance. Default: 10.0</p> Integer <p>Number og segments. Default: 5</p> Enumeration <p>Controls how line endings are handled in the buffer. Default: 0  (One of: 0 \u2014 Round, 1 \u2014 Flat, 2 \u2014 Square)</p> Enumeration <p>Specifies whether round, miter or beveled joins should be used when offsetting corners in a line. Default: 0 (Options are: 0 \u2014 Round, 1 \u2014 Miter, 2 \u2014 Bevel)</p> Integer <p>Sets the maximum distance from the offset geometry to use when creating a mitered join as a factor of the offset distance Default: 0, Minimum: 1</p> Boolean <p>Dissolve the final buffer. Default: false.</p>"},{"location":"workers/#python.engine.workers.Worker.Vector.bufferLayer--returns","title":"Returns","text":"<p>QgsVectorLayer [vector: polygon]     The result output from the algorithem</p> Source code in <code>python\\engine\\workers.py</code> <pre><code>def bufferLayer(layer: QgsVectorLayer, distance: int, segements: int, endcapStyle: int, joinStyle: int, miterLimit: int, dissolve: bool):\n    \"\"\"\n    Computes a buffer area for all the features in an input layer, using a fixed or data defined distance.\n    It is possible to use a negative distance for polygon input layers.\n    In this case the buffer will result in a smaller polygon (setback).\n    QGIS processing algorithem: native:buffer\n\n    Parameters\n    ----------\n    layer : QgsVectorLayer [vector: any]\n        The QgsVectorLayer input for the algorithem\n\n    distance : Integer\n        The buffer distance. Default: 10.0\n\n    segements : Integer\n        Number og segments. Default: 5\n\n    endcapStyle : Enumeration\n        Controls how line endings are handled in the buffer. Default: 0 \n        (One of: 0 \u2014 Round, 1 \u2014 Flat, 2 \u2014 Square)\n\n    joinStyle : Enumeration\n        Specifies whether round, miter or beveled joins should be used when offsetting corners in a line.\n        Default: 0 (Options are: 0 \u2014 Round, 1 \u2014 Miter, 2 \u2014 Bevel)\n\n    miterLimit : Integer\n        Sets the maximum distance from the offset geometry to use when creating a mitered join as a factor of the offset distance\n        Default: 0, Minimum: 1\n\n    dissolve : Boolean\n        Dissolve the final buffer. Default: false.\n\n\n    Returns\n    -------\n    QgsVectorLayer [vector: polygon]\n        The result output from the algorithem\n    \"\"\"\n\n    logger.info(\"Creating buffer layer\")\n    if layerHasFeatures(layer):\n        logger.info(\"Processing \" + str(layer.featureCount()) +\" features\")\n    try:\n        parameter = {\n            'INPUT': layer,\n            'DISTANCE': distance,\n            'SEGMENTS': segements,\n            'END_CAP_STYLE': endcapStyle,\n            'JOIN_STYLE': joinStyle,\n            'MITER_LIMIT': miterLimit,\n            'DISSOLVE': dissolve,\n            'OUTPUT': 'memory:buffer'\n        }\n        logger.info(f'Parameters: {str(parameter)}')\n        result = processing.run('native:buffer', parameter, feedback=Worker.progress)['OUTPUT']\n        logger.info(\"BufferLayer finished\")\n        return result\n    except Exception as error:\n        logger.error(\"An error occured in BufferLayer\")\n        logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n        logger.critical(\"Program terminated\" )\n        sys.exit()\n</code></pre>"},{"location":"workers/#python.engine.workers.Worker.Vector.clip","title":"<code>clip(layer, overlay)</code>","text":"<p>Clips a vector layer using the features of an additional polygon layer. Only the parts of the features in the input layer that fall within the polygons of  the overlay layer will be added to the resulting layer.</p>"},{"location":"workers/#python.engine.workers.Worker.Vector.clip--parameters","title":"Parameters","text":"<p>layer : QgsVectorLayer [vector: any]     Layer containing the features to be clipped</p> [vector: polygon] <p>Layer containing the clipping features</p>"},{"location":"workers/#python.engine.workers.Worker.Vector.clip--returns","title":"Returns","text":"<p>QgsVectorLayer [vector: any]     Layer to contain the features from the input layer that are inside the overlay (clipping) layer</p> Source code in <code>python\\engine\\workers.py</code> <pre><code>def clip(layer: QgsVectorLayer, overlay: str):\n    \"\"\"\n    Clips a vector layer using the features of an additional polygon layer.\n    Only the parts of the features in the input layer that fall within the polygons of \n    the overlay layer will be added to the resulting layer.\n\n    Parameters\n    ----------\n    layer : QgsVectorLayer [vector: any]\n        Layer containing the features to be clipped\n\n    overlay : [vector: polygon]\n        Layer containing the clipping features\n\n    Returns\n    -------\n    QgsVectorLayer [vector: any]\n        Layer to contain the features from the input layer that are inside the overlay (clipping) layer\n    \"\"\"\n    logger.info(\"Clipping layers\")\n    try:\n        parameter = {\n            'INPUT': layer,\n            'OVERLAY': overlay,\n            'OUTPUT': 'memory:extracted'\n        }\n        logger.info(f'Parameters: {str(parameter)}')\n        result = processing.run('native:clip', parameter, feedback=Worker.progress)['OUTPUT']\n        logger.info(\"Clip  finished\")\n        return result\n    except Exception as error:\n        logger.error(\"An error occured in Clip\")\n        logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n        logger.critical(\"Program terminated\" )\n        sys.exit()\n</code></pre>"},{"location":"workers/#python.engine.workers.Worker.Vector.concavehull","title":"<code>concavehull(inputlayer, alpha, holes, multigeom)</code>","text":"<p>Computes the concave hull of the features from an input point layer.</p>"},{"location":"workers/#python.engine.workers.Worker.Vector.concavehull--parameters","title":"Parameters","text":"<p>inputlayer : QgsVectorLayer [point]     Input point vector layer</p> float <p>Number from 0 (maximum concave hull) to 1 (convex hull).</p> bool <p>Choose whether to allow holes in the final concave hull</p> bool <p>Check if you want to have singlepart geometries instead of multipart ones.</p>"},{"location":"workers/#python.engine.workers.Worker.Vector.concavehull--returns","title":"Returns","text":"<p>QgsVectorLayer [polygon]     Specify the output vector layer</p> Source code in <code>python\\engine\\workers.py</code> <pre><code>def concavehull(inputlayer:QgsVectorLayer, alpha: float, holes: bool, multigeom: bool ):\n    \"\"\"\n    Computes the concave hull of the features from an input point layer.\n\n    Parameters\n    ----------\n    inputlayer : QgsVectorLayer [point]\n        Input point vector layer\n\n    alpha : float\n        Number from 0 (maximum concave hull) to 1 (convex hull).\n\n    holes : bool\n        Choose whether to allow holes in the final concave hull\n\n    multigeom : bool\n        Check if you want to have singlepart geometries instead of multipart ones.\n\n    Returns\n    -------\n    QgsVectorLayer [polygon]\n        Specify the output vector layer\n    \"\"\"\n    logger.info('calcualting concavehull')\n    try:\n        parameters = {\n            'INPUT': inputlayer,\n            'ALPHA' : alpha,\n            'HOLES' : holes,\n            'NO_MULTIGEOMETRY' : multigeom,\n            'OUTPUT': 'memory:output_from_concavehull'\n        }\n        logger.info(f'Parameters: {str(parameters)}')\n        result = processing.run('native:concavehull', parameters, feedback=Worker.progress)['OUTPUT']\n        logger.info('concavehull finished')\n        return result\n    except Exception as error:\n        logger.error(\"An error occured in concavehull\")\n        logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n        logger.critical(\"Program terminated\" )\n        script_failed()            \n</code></pre>"},{"location":"workers/#python.engine.workers.Worker.Vector.convexhull","title":"<code>convexhull(layer)</code>","text":"<p>Calculates the convex hull for each feature in an input layer.</p>"},{"location":"workers/#python.engine.workers.Worker.Vector.convexhull--parameters","title":"Parameters","text":"<p>layer : QgsVectorLayer     Input vector layer</p>"},{"location":"workers/#python.engine.workers.Worker.Vector.convexhull--returns","title":"Returns","text":"<p>QgsVectorLayer     Specify the output vector layer.</p> Source code in <code>python\\engine\\workers.py</code> <pre><code>def convexhull(layer: QgsVectorLayer):\n    \"\"\"\n    Calculates the convex hull for each feature in an input layer.\n\n    Parameters\n    ----------\n    layer : QgsVectorLayer\n        Input vector layer\n\n    Returns\n    -------\n    QgsVectorLayer\n        Specify the output vector layer.\n    \"\"\"\n    logger.info(f\" Calculating convexhull for layer {layer}\")\n    try:\n        parameter = {\n            'INPUT': layer,\n            'OUTPUT': 'memory:output_from_convexhull'\n        }\n        result = processing.run('native:convexhull', parameter, feedback=Worker.progress)['OUTPUT']\n        logger.info(f'Parameters: {str(parameter)}')\n        logger.info(\"convexhull  finished\")\n        return result\n    except Exception as error:\n        logger.error(\"An error occured in convexhull\")\n        logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n        logger.critical(\"Program terminated\" )\n        sys.exit()\n</code></pre>"},{"location":"workers/#python.engine.workers.Worker.Vector.countpointsinpolygon","title":"<code>countpointsinpolygon(polygons, points, weight, fieldname)</code>","text":"<p>Takes a point and a polygon layer and counts the number of points from the point layer in each of the polygons of the polygon layer. A new polygon layer is generated, with the exact same content as the input polygon layer, but containing an additional field with the points count corresponding to each polygon.</p>"},{"location":"workers/#python.engine.workers.Worker.Vector.countpointsinpolygon--parameters","title":"Parameters","text":"<p>polygons : QgsVectorLayer     Polygon layer whose features are associated with the count of points they contain</p> QgsVectorLayer <p>Point layer with features to count</p> str <p>A field from the point layer. The count generated will be the sum of the weight field of the points contained by the polygon.  If the weight field is not numeric, the count will be 0.</p> str <p>The name of the field to store the count of points</p>"},{"location":"workers/#python.engine.workers.Worker.Vector.countpointsinpolygon--returns","title":"Returns","text":"<p>QgsVectorLayer     Specification of the output layer.</p> Source code in <code>python\\engine\\workers.py</code> <pre><code>def countpointsinpolygon(polygons: QgsVectorLayer, points: QgsVectorLayer, weight : str, fieldname: str):\n    \"\"\"\n    Takes a point and a polygon layer and counts the number of points from the point layer in each of the polygons of the polygon layer.\n    A new polygon layer is generated, with the exact same content as the input polygon layer, but containing an additional field with the points count corresponding to each polygon.\n\n    Parameters\n    ----------\n    polygons : QgsVectorLayer\n        Polygon layer whose features are associated with the count of points they contain\n\n    points : QgsVectorLayer\n        Point layer with features to count\n\n    weight : str\n        A field from the point layer. The count generated will be the sum of the weight field of the points contained by the polygon. \n        If the weight field is not numeric, the count will be 0.\n\n    fieldname : str\n        The name of the field to store the count of points\n\n    Returns\n    -------\n    QgsVectorLayer\n        Specification of the output layer.\n    \"\"\"\n    logger.info('Conducting point in polygon')\n    try:\n        if isinstance(weight, int):\n            value = weight\n        else:\n            value = 0\n\n        parameters = {\n            'POLYGONS': polygons,\n            'POINTS': points,\n            'WEIGHT': value,\n            'FIELD' : fieldname,\n            'OUTPUT': 'memory:output_from_countpointsinpolygon'\n        }\n        logger.info(f'Parameters: {str(parameters)}')\n        result = processing.run('native:Countpointsinpolygon', parameters, feedback=Worker.progress)['OUTPUT']\n        logger.info('Promote to multipart finished')\n        return result\n    except Exception as error:\n        logger.error(\"An error occured in Countpointsinpolygon\")\n        logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n        logger.critical(\"Program terminated\" )\n        script_failed()  \n</code></pre>"},{"location":"workers/#python.engine.workers.Worker.Vector.createCentroids","title":"<code>createCentroids(layer)</code>","text":"<p>Creates a new point layer, with points representing the centroids of the geometries of the input layer. The centroid is a single point representing the barycenter (of all parts) of the feature, so it can be outside the feature borders. But can also be a point on each part of the feature. The attributes of the points in the output layer are the same as for the original features.</p>"},{"location":"workers/#python.engine.workers.Worker.Vector.createCentroids--parameters","title":"Parameters","text":"<p>layer : QgsVectorLayer [vector: any]     The QgsVectorLayer input for the algorithem</p>"},{"location":"workers/#python.engine.workers.Worker.Vector.createCentroids--returns","title":"Returns","text":"<p>QgsVectorLayer [vector: any]     The result output from the algorithem</p> Source code in <code>python\\engine\\workers.py</code> <pre><code>def createCentroids(layer: str):\n    \"\"\"\n    Creates a new point layer, with points representing the centroids of the geometries of the input layer.\n    The centroid is a single point representing the barycenter (of all parts) of the feature, so it can be outside the feature borders. But can also be a point on each part of the feature.\n    The attributes of the points in the output layer are the same as for the original features.\n\n    Parameters\n    ----------\n    layer : QgsVectorLayer [vector: any]\n        The QgsVectorLayer input for the algorithem\n\n\n    Returns\n    -------\n    QgsVectorLayer [vector: any]\n        The result output from the algorithem\n\n    \"\"\"\n    logger.info(\"Creating centroids\")\n    if layerHasFeatures(layer):\n        logger.info(\"Processing \" + str(layer.featureCount()) +\" features\")\n    try:\n        parameter = {\n            'INPUT': layer,\n            'ALL_PARTS':False,\n            'OUTPUT': 'memory:buffer'\n        }\n        logger.info(f'Parameters: {str(parameter)}')\n        result = processing.run('native:centroids', parameter, feedback=Worker.progress)['OUTPUT']\n        logger.info(\"Centroids finished\")\n        return result\n    except Exception as error:\n        logger.error(\"An error occured in createCentroids\")\n        logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n        logger.critical(\"Program terminated\" )\n        script_failed()\n</code></pre>"},{"location":"workers/#python.engine.workers.Worker.Vector.dbscanclustering","title":"<code>dbscanclustering(inputlayer, min_clusters, max_dist)</code>","text":"<p>Clusters point features based on a 2D implementation of Density-based spatial clustering of applications with noise (DBSCAN) algorithm. The algorithm requires two parameters, a minimum cluster size, and the maximum distance allowed between clustered points.</p>"},{"location":"workers/#python.engine.workers.Worker.Vector.dbscanclustering--parameters","title":"Parameters","text":"<p>inputlayer : QgsVectorLayer     Layer to analyze</p> int <p>Minimum number of features to generate a cluster</p> int <p>Distance beyond which two features can not belong to the same cluster (eps)</p>"},{"location":"workers/#python.engine.workers.Worker.Vector.dbscanclustering--returns","title":"Returns","text":"<p>QgsVectorLayer     Specify the vector layer for the result of the clustering.</p> Source code in <code>python\\engine\\workers.py</code> <pre><code>def dbscanclustering(inputlayer: QgsVectorLayer, min_clusters: int, max_dist: int ):\n    \"\"\"\n    Clusters point features based on a 2D implementation of Density-based spatial clustering of applications with noise (DBSCAN) algorithm.\n    The algorithm requires two parameters, a minimum cluster size, and the maximum distance allowed between clustered points.\n\n    Parameters\n    ----------\n    inputlayer : QgsVectorLayer\n        Layer to analyze\n\n    min_clusters : int\n        Minimum number of features to generate a cluster\n\n    max_dist : int\n        Distance beyond which two features can not belong to the same cluster (eps)\n\n    Returns\n    -------\n    QgsVectorLayer\n        Specify the vector layer for the result of the clustering.\n    \"\"\"\n    logger.info('Performing DBScan clustering')\n    try:\n        parameters = {\n            'INPUT': inputlayer,\n            'MIN_SIZE' : min_clusters,\n            'EPS': max_dist,\n            'OUTPUT': 'memory:output_from_dbscanclustering'\n        }\n        logger.info(f'Parameters: {str(parameters)}')\n        result = processing.run('native:dbscanclustering', parameters, feedback=Worker.progress)['OUTPUT']\n        logger.info('Dbscanclustering finished')\n        return result\n    except Exception as error:\n        logger.error(\"An error occured in Dbscanclustering\")\n        logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n        logger.critical(\"Program terminated\" )\n        script_failed()\n</code></pre>"},{"location":"workers/#python.engine.workers.Worker.Vector.deleteColumns","title":"<code>deleteColumns(layer, columns)</code>","text":"<p>Takes a vector layer and generates a new one that has the same features but without the selected columns.</p>"},{"location":"workers/#python.engine.workers.Worker.Vector.deleteColumns--parameters","title":"Parameters","text":"<p>layer : QgsVectorLayer     Input vector layer to drop field(s) from</p> List of tablefields <p>The field(s) to drop</p>"},{"location":"workers/#python.engine.workers.Worker.Vector.deleteColumns--returns","title":"Returns","text":"<p>QgsVectorLayer     The QgsVectorLayer output layer.</p> Source code in <code>python\\engine\\workers.py</code> <pre><code>def deleteColumns (layer: QgsVectorLayer, columns: list):\n    \"\"\"\n    Takes a vector layer and generates a new one that has the same features but without the selected columns.\n\n    Parameters\n    ----------\n    layer : QgsVectorLayer\n        Input vector layer to drop field(s) from\n\n    columns : List of tablefields\n        The field(s) to drop\n\n    Returns\n    -------\n    QgsVectorLayer\n        The QgsVectorLayer output layer.\n    \"\"\"\n    logger.info(\"deleting fields\")\n\n    try:\n        parameter = {\n            'INPUT': layer,\n            'COLUMN':columns,\n            'OUTPUT': 'memory:extracted'\n        }\n        result = processing.run('native:deletecolumn', parameter, feedback=Worker.progress)['OUTPUT']\n        logger.info(f'Parameters: {str(parameter)}')\n        logger.info(\"deleteColumns  finished\")\n        return result\n    except Exception as error:\n        logger.error(\"An error occured in deleteColumns\")\n        logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n        logger.critical(\"Program terminated\" )\n        sys.exit()\n</code></pre>"},{"location":"workers/#python.engine.workers.Worker.Vector.delete_geopacakge_layers","title":"<code>delete_geopacakge_layers(geopackage, layernames)</code>","text":"<p>Deletes one or more tables from a geopackage</p>"},{"location":"workers/#python.engine.workers.Worker.Vector.delete_geopacakge_layers--parameters","title":"Parameters","text":"<p>geopackage : str     The full path for the geopackage file layernames : list     List of layernames to be deleted</p> Source code in <code>python\\engine\\workers.py</code> <pre><code>def delete_geopacakge_layers(geopackage: str, layernames: list):\n    \"\"\"\n    Deletes one or more tables from a geopackage\n\n    Parameters\n    ----------\n    geopackage : str\n        The full path for the geopackage file\n    layernames : list\n        List of layernames to be deleted\n\n    \"\"\"\n    logger.info(\"Performing delete_geopacakge_layer\")\n    logger.info(f\"Deleting layers {layernames}\")\n\n    if os.path.isfile(geopackage):\n        try:\n            for layer in layernames:\n                logger.info(f\"Deleting layer {layer}\")\n                parameter = {'DATABASE':'{0}|layername={1}'.format(geopackage, layer),\n                'SQL':'drop table {0}'.format(layer)}\n                logger.info(f'Parameters: {str(parameter)}')\n                processing.run(\"native:spatialiteexecutesql\", parameter )\n                logger.info(f\"Layer deleted\")\n            logger.info(f\"Finished deleting layers\")\n\n\n        except Exception as error:\n            logger.error(\"An error occured in delete_geopacakge_layer\")\n            logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n            logger.critical(\"Program terminated\" )\n            script_failed()\n    else:    \n        pass\n</code></pre>"},{"location":"workers/#python.engine.workers.Worker.Vector.difference","title":"<code>difference(layer, overlay)</code>","text":"<p>Extracts features from the input layer that don\u2019t fall within the boundaries of the overlay layer. Input layer features that partially overlap the overlay layer feature(s) are split along the  boundary of those feature(s.</p>"},{"location":"workers/#python.engine.workers.Worker.Vector.difference--parameters","title":"Parameters","text":"<p>layer : QgsVectorLayer [vector: any]     Layer to extract (parts of) features from.</p> QgsVectorLayer [vector: any] <p>Layer containing the geometries that will be subtracted from the iniput layer geometries</p>"},{"location":"workers/#python.engine.workers.Worker.Vector.difference--returns","title":"Returns","text":"<p>QgsVectorLayer [vector: polygon/line]     The result output from the algorithem</p> Source code in <code>python\\engine\\workers.py</code> <pre><code>def difference(layer: QgsVectorLayer, overlay: QgsVectorLayer):\n    \"\"\"\n    Extracts features from the input layer that don\u2019t fall within the boundaries of the overlay layer.\n    Input layer features that partially overlap the overlay layer feature(s) are split along the \n    boundary of those feature(s.\n\n    Parameters\n    ----------\n    layer : QgsVectorLayer [vector: any]\n        Layer to extract (parts of) features from.\n\n    overlay : QgsVectorLayer [vector: any]\n        Layer containing the geometries that will be subtracted from the iniput layer geometries\n\n    Returns\n    -------\n    QgsVectorLayer [vector: polygon/line]\n        The result output from the algorithem\n    \"\"\"\n    logger.info(\"Finding differences\")\n    try:\n        parameter = {\n            'INPUT': layer,\n            'OVERLAY': overlay,\n            'OUTPUT': 'memory:extracted'\n        }\n        logger.info(f'Parameters: {str(parameter)}')\n        result = processing.run('native:difference', parameter, feedback=Worker.progress)['OUTPUT']\n        logger.info(\"Difference  finished\")\n        return result\n    except Exception as error:\n        logger.error(\"An error occured in Difference\")\n        logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n        logger.critical(\"Program terminated\" )\n        sys.exit()\n</code></pre>"},{"location":"workers/#python.engine.workers.Worker.Vector.dissolveFeatures","title":"<code>dissolveFeatures(layer, fieldList, disjoined)</code>","text":"<p>Takes a vector layer and combines its features into new features.  One or more attributes can be specified to dissolve features belonging to the same class  (having the same value for the specified attributes), alternatively all features can be dissolved to a single feature. All output geometries will be converted to multi geometries.  QGIS processing algorithem: native:dissolve.</p>"},{"location":"workers/#python.engine.workers.Worker.Vector.dissolveFeatures--parameters","title":"Parameters","text":"<p>layer : QgsVectorLayer [vector: any]     The QgsVectorLayer input for the algorithem</p> List <p>List of fields to dissolve on. Default []</p> Boolean <p>Keep disjoint features separate ? Default: False</p>"},{"location":"workers/#python.engine.workers.Worker.Vector.dissolveFeatures--returns","title":"Returns","text":"<p>QgsVectorLayer [vector: polygon]     The result output from the algorithem</p> Source code in <code>python\\engine\\workers.py</code> <pre><code>def dissolveFeatures(layer: QgsVectorLayer, fieldList: list, disjoined: bool):\n    \"\"\"\n    Takes a vector layer and combines its features into new features. \n    One or more attributes can be specified to dissolve features belonging to the same class \n    (having the same value for the specified attributes), alternatively all features can be dissolved to a single feature.\n    All output geometries will be converted to multi geometries. \n    QGIS processing algorithem: native:dissolve.\n\n    Parameters\n    ----------\n    layer : QgsVectorLayer [vector: any]\n        The QgsVectorLayer input for the algorithem\n\n    fieldList : List\n        List of fields to dissolve on. Default []\n\n    disjoined : Boolean\n        Keep disjoint features separate ? Default: False\n\n\n    Returns\n    -------\n    QgsVectorLayer [vector: polygon]\n        The result output from the algorithem\n\n    \"\"\"\n    logger.info(\"Dissolving features\")\n    if layerHasFeatures(layer):\n        logger.info(\"Processing \" + str(layer.featureCount()) +\" features\")\n    try:\n        parameter = {\n            'INPUT': layer,\n            'FIELD' : fieldList,\n            'SEPARATE_DISJOINT' : False,\n            'OUTPUT': 'memory:dissolved'\n        }\n        logger.info(f'Parameters: {str(parameter)}')\n        result = processing.run('native:dissolve', parameter, feedback=Worker.progress)['OUTPUT']\n        logger.info(\"DissolveFeatures finished\")\n        if layerHasFeatures(result):\n            logger.info(\"Returning \" + str(result.featureCount()) +\" features\")\n        return result\n    except Exception as error:\n        logger.error(\"An error occured in dissolveFeatures\")\n        logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n        logger.critical(\"Program terminated\" )\n        sys.exit()\n</code></pre>"},{"location":"workers/#python.engine.workers.Worker.Vector.execute_sql","title":"<code>execute_sql(connection, databasetype, sql_expression, pgdb_name=None, driver=None)</code>","text":"<p>Execute an SQL query against a database.  This can be used to create tables, truncate, build indexes etc. The database type must be specified in the 'database' parameter (one of 'Mssql' or 'Postgres') The default Mssql driver is 'SQL Server' - if this needs to be overwritten, specify the parameter driver, else leave it empty. SQL statments must be trippel double-quoted - prepare the statement in the QGIS sql executor tool for testing. </p>"},{"location":"workers/#python.engine.workers.Worker.Vector.execute_sql--parameters","title":"Parameters","text":"<p>connection : str     Name of a database connection from settings.json databasetype : str     The database type, one of 'Mssql' or 'Postgres'. sql_expression : str     The SQL expression to be executed. Use trippel double-quotes arraound the expression pgdb_name: str     Name of postgres database if databasetype is  Postgres. Defaults to None. driver : str     Defaults to None. The name of the Mssql driver, if 'SQL Server' is not working.</p>"},{"location":"workers/#python.engine.workers.Worker.Vector.execute_sql--returns","title":"Returns","text":"<p>Errorcode : int     Returns 0 if the SQL is executed without errors.</p> Source code in <code>python\\engine\\workers.py</code> <pre><code>def execute_sql(connection, databasetype, sql_expression, pgdb_name=None, driver=None):\n    \"\"\"\n    Execute an SQL query against a database. \n    This can be used to create tables, truncate, build indexes etc.\n    The database type must be specified in the 'database' parameter (one of 'Mssql' or 'Postgres')\n    The default Mssql driver is 'SQL Server' - if this needs to be overwritten, specify the parameter driver, else leave it empty.\n    SQL statments must be trippel double-quoted - prepare the statement in the QGIS sql executor tool for testing. \n\n    Parameters\n    ----------\n    connection : str\n        Name of a database connection from settings.json\n    databasetype : str\n        The database type, one of 'Mssql' or 'Postgres'.\n    sql_expression : str\n        The SQL expression to be executed. Use trippel double-quotes arraound the expression\n    pgdb_name: str\n        Name of postgres database if databasetype is  Postgres. Defaults to None.\n    driver : str\n        Defaults to None. The name of the Mssql driver, if 'SQL Server' is not working.\n\n    Returns\n    -------\n    Errorcode : int\n        Returns 0 if the SQL is executed without errors.\n\n    \"\"\"\n\n    config = get_config()\n    if databasetype in ('Postgres', 'Mssql'):\n        logger.info(f'Running SQL executor on {databasetype}' )\n    else :\n        logger.info(f'Unsupported database: {databasetype}, use one of \"Mssql\" or \"Postgres\"' )\n        logger.critical(\"Program terminated\" )\n        sys.exit()\n    try:\n        dbconnection = config['DatabaseConnections'][connection]\n        if databasetype == 'Mssql':\n            import pyodbc \n            if driver == \"\":\n                mssqldriver = 'SQL Server'\n            else :\n                mssqldriver = 'driver'\n            cnxn = pyodbc.connect('DRIVER={'+mssqldriver+'};Server='+dbconnection['host']+';Database='+dbconnection['databasename']+';User ID='+dbconnection['user']+';Password='+dbconnection['password'])\n            logger.info(\"Using connection :\" + 'DRIVER={'+mssqldriver+'};Server='+dbconnection['host']+';Database='+dbconnection['databasename']+';User ID='+dbconnection['user']+';Password=xxxxxxxx')\n            cursor = cnxn.cursor()\n            logger.info(f'Query: {sql_expression}' )\n            cursor.execute(sql_expression) \n            logger.info(\"SQL executor finished\")\n            return 0\n\n        if databasetype == 'Postgres':\n            import psycopg2\n            connection = psycopg2.connect(user=dbconnection['user'], password=dbconnection['password'], host=dbconnection['host'], port=dbconnection['port'], database=pgdb_name)\n            logger.info(\"Using connection : user=\"+ dbconnection['user']+\", password=xxxxxx, host=\"+dbconnection['host']+\", port=\"+dbconnection['port']+\", database=\"+pgdb_name )\n            cursor = connection.cursor()\n            logger.info(f'Query: {sql_expression}' )\n            cursor.execute(sql_expression)\n            connection.commit()\n            cursor.close()\n            connection.close()\n            logger.info(\"SQL executor finished\")\n            return 0\n\n    except Exception as error:\n        logger.error(\"An error occured running SQL executor\")\n        logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n        logger.critical(\"Program terminated\" )\n        sys.exit()\n</code></pre>"},{"location":"workers/#python.engine.workers.Worker.Vector.extractByExpression","title":"<code>extractByExpression(layer, expression)</code>","text":"<p>Creates a vector layer from an input layer, containing only matching features. The criteria for adding features to the resulting layer is based on a QGIS expression.</p>"},{"location":"workers/#python.engine.workers.Worker.Vector.extractByExpression--parameters","title":"Parameters","text":"<p>layer : QgsVectorLayer     The QgsVectorLayer that is used as input.</p> String <p>Expression to filter the vector layer</p>"},{"location":"workers/#python.engine.workers.Worker.Vector.extractByExpression--returns","title":"Returns","text":"<p>QgsVectorLayer     The QgsVectorLayer output layer.</p> Source code in <code>python\\engine\\workers.py</code> <pre><code>def extractByExpression(layer: QgsVectorLayer, expression: str):\n    \"\"\"\n    Creates a vector layer from an input layer, containing only matching features.\n    The criteria for adding features to the resulting layer is based on a QGIS expression.\n\n    Parameters\n    ----------\n    layer : QgsVectorLayer\n        The QgsVectorLayer that is used as input.\n\n    expression : String\n        Expression to filter the vector layer\n\n    Returns\n    -------\n    QgsVectorLayer\n        The QgsVectorLayer output layer.\n    \"\"\"\n    logger.info(\"Extracting by expression\")\n    try:\n        parameter = {\n            'INPUT': layer,\n            'EXPRESSION': expression,\n            'OUTPUT': 'memory:extracted'\n        }\n        logger.info(f'Parameters: {str(parameter)}')\n        result = processing.run('native:extractbyexpression', parameter, feedback=Worker.progress)['OUTPUT']\n        logger.info(\"Extractbyexpression  finished\")\n        return result\n    except Exception as error:\n        logger.error(\"An error occured in extractByExpression\")\n        logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n        logger.critical(\"Program terminated\" )\n        sys.exit()\n</code></pre>"},{"location":"workers/#python.engine.workers.Worker.Vector.extractByLocation","title":"<code>extractByLocation(layer, predicate, intersect)</code>","text":"<p>summary</p>"},{"location":"workers/#python.engine.workers.Worker.Vector.extractByLocation--parameters","title":"Parameters","text":"<p>layer : QgsVectorLayer [vector: any]     Input vector layer. </p> [enumeration] Default: [0] <p>Type of spatial relation the source feature should have with the target feature so that they could be joined. One or more of: 0 \u2014 intersect, 1 \u2014 contain, 2 \u2014 equal, 3 \u2014 touch, 4 \u2014 overlap, 5 \u2014 are within 6 \u2014 cross.</p> QgsVectorLayer [vector: any] <p>Intersection vector layer</p>"},{"location":"workers/#python.engine.workers.Worker.Vector.extractByLocation--returns","title":"Returns","text":"<p>QgsVectorLayer [vector: any]     the output vector layer for the join.</p> Source code in <code>python\\engine\\workers.py</code> <pre><code>def extractByLocation(layer: QgsVectorLayer, predicate: int, intersect: str):\n    \"\"\"_summary_\n\n    Parameters\n    ----------\n    layer : QgsVectorLayer [vector: any]\n        Input vector layer. \n\n    predicate : [enumeration] Default: [0]\n        Type of spatial relation the source feature should have with the target feature so that they could be joined. One or more of:\n        0 \u2014 intersect, 1 \u2014 contain, 2 \u2014 equal, 3 \u2014 touch, 4 \u2014 overlap, 5 \u2014 are within 6 \u2014 cross.\n\n    intersect : QgsVectorLayer [vector: any]\n        Intersection vector layer\n\n    Returns\n    -------\n    QgsVectorLayer [vector: any]\n        the output vector layer for the join.\n    \"\"\"\n    logger.info(\"Extracting by location\")\n    try:\n        parameter = {\n            'INPUT': layer,\n            'PREDICATE':predicate,\n            'INTERSECT':intersect,\n            'OUTPUT': 'memory:extracted'\n        }\n        logger.info(f'Parameters: {str(parameter)}')\n        result = processing.run('native:extractbylocation', parameter, feedback=Worker.progress)['OUTPUT']\n        logger.info(\"extractByLocation finished\")\n        return result\n    except Exception as error:\n        logger.error(\"An error occured in extractByLocation\")\n        logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n        logger.critical(\"Program terminated\" )\n        sys.exit()\n</code></pre>"},{"location":"workers/#python.engine.workers.Worker.Vector.extractvertices","title":"<code>extractvertices(inputlayer)</code>","text":"<p>Takes a vector layer and generates a point layer with points representing the vertices in the input geometries. The attributes associated to each point are the same ones associated to the feature that the vertex belongs to. Additional fields are added to the vertices indicating the vertex index (beginning at 0), the feature\u2019s part and its index within the part (as well as its ring for polygons), distance along original geometry and bisector angle of vertex for original geometry.</p>"},{"location":"workers/#python.engine.workers.Worker.Vector.extractvertices--parameters","title":"Parameters","text":"<p>inputlayer : QgsVectorLayer     Input vector layer</p>"},{"location":"workers/#python.engine.workers.Worker.Vector.extractvertices--returns","title":"Returns","text":"<p>QgsVectorLayer [point]     Specify the output vector layer</p> Source code in <code>python\\engine\\workers.py</code> <pre><code>def extractvertices(inputlayer:QgsVectorLayer):\n    \"\"\"\n    Takes a vector layer and generates a point layer with points representing the vertices in the input geometries.\n    The attributes associated to each point are the same ones associated to the feature that the vertex belongs to.\n    Additional fields are added to the vertices indicating the vertex index (beginning at 0), the feature\u2019s part and its index within the part\n    (as well as its ring for polygons), distance along original geometry and bisector angle of vertex for original geometry.\n\n    Parameters\n    ----------\n    inputlayer : QgsVectorLayer\n        Input vector layer\n\n    Returns\n    -------\n    QgsVectorLayer [point]\n        Specify the output vector layer\n    \"\"\"\n    logger.info('Extracting vertices')\n    try:\n        parameters = {\n            'INPUT': inputlayer,\n            'OUTPUT': 'memory:output_from_extractvertices'\n        }\n        logger.info(f'Parameters: {str(parameters)}')\n        result = processing.run('native:extractvertices', parameters, feedback=Worker.progress)['OUTPUT']\n        logger.info('extractvertices finished')\n        return result\n    except Exception as error:\n        logger.error(\"An error occured in extractvertices\")\n        logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n        logger.critical(\"Program terminated\" )\n        script_failed()    \n</code></pre>"},{"location":"workers/#python.engine.workers.Worker.Vector.fieldCalculator","title":"<code>fieldCalculator(layer, fieldname, fieldtype, fieldlength, fieldprecision, formula)</code>","text":"<p>Scripting the field calcualtor You can use all the supported expressions and functions. The original layer is not modified. A new layer is generated where the attribute table contains the calucalted field QGIS processing algorithem: native:fieldcalculator</p>"},{"location":"workers/#python.engine.workers.Worker.Vector.fieldCalculator--parameters","title":"Parameters","text":"<p>layer : QgsVectorLayer [vector: any]     The QgsVectorLayer input for the algorithem</p> String <p>The name of the new calcualted field</p> Enumeration <p>Type of the field,  Default: 0  (0 \u2014 Float, 1 \u2014 Integer, 2 \u2014 String, 3 \u2014 Date)</p> Integer <p>Lenght of the field, Default: 10.</p> Integer <p>Precision of the field, Default: 3.</p> Expression <p>The expression that populates the values of the field.</p>"},{"location":"workers/#python.engine.workers.Worker.Vector.fieldCalculator--returns","title":"Returns","text":"<p>QgsVectorLayer [vector: any]     The result output from the algorithem</p> Source code in <code>python\\engine\\workers.py</code> <pre><code>def fieldCalculator (layer: QgsVectorLayer, fieldname: str, fieldtype: int, fieldlength: int, fieldprecision: int, formula: str):\n    \"\"\"\n    Scripting the field calcualtor\n    You can use all the supported expressions and functions.\n    The original layer is not modified. A new layer is generated where the attribute table contains the calucalted field\n    QGIS processing algorithem: native:fieldcalculator\n\n    Parameters\n    ----------\n    layer : QgsVectorLayer [vector: any]\n        The QgsVectorLayer input for the algorithem\n\n    fieldname : String\n        The name of the new calcualted field\n\n    fieldtype : Enumeration\n        Type of the field,  Default: 0  (0 \u2014 Float, 1 \u2014 Integer, 2 \u2014 String, 3 \u2014 Date)\n\n    fieldlength : Integer\n        Lenght of the field, Default: 10.\n\n    fieldprecision : Integer\n        Precision of the field, Default: 3.\n\n    formula : Expression\n        The expression that populates the values of the field.\n\n\n    Returns\n    -------\n    QgsVectorLayer [vector: any]\n        The result output from the algorithem\n    \"\"\"\n    logger.info(\"Calculating field\")\n    try:\n        parameter = {\n            'INPUT': layer,\n            'FIELD_NAME': fieldname,\n            'FIELD_TYPE': fieldtype,\n            'FIELD_LENGTH': fieldlength,\n            'FIELD_PRECISION': fieldprecision,\n            'FORMULA': formula,\n            'OUTPUT': 'memory:extracted'\n        }\n        result = processing.run('native:fieldcalculator', parameter, feedback=Worker.progress)['OUTPUT']\n        logger.info(f'Parameters: {str(parameter)}')\n        logger.info(\"fieldCalculator  finished\")\n        return result\n    except Exception as error:\n        logger.error(\"An error occured in fieldCalculator\")\n        logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n        logger.critical(\"Program terminated\" )\n        sys.exit()\n</code></pre>"},{"location":"workers/#python.engine.workers.Worker.Vector.fixGeometry","title":"<code>fixGeometry(layer)</code>","text":"<p>Attempts to create a valid representation of a given invalid geometry without losing any of the input vertices. Already valid geometries are returned without further intervention. Always outputs multi-geometry layer. QGIS processing algorithem: native:fixgeometries</p>"},{"location":"workers/#python.engine.workers.Worker.Vector.fixGeometry--parameters","title":"Parameters","text":"<p>layer : QgsVectorLayer [vector: any]     The QgsVectorLayer input for the algorithem</p>"},{"location":"workers/#python.engine.workers.Worker.Vector.fixGeometry--returns","title":"Returns","text":"<p>QgsVectorLayer [vector: any]     The result output from the algorithem</p> Source code in <code>python\\engine\\workers.py</code> <pre><code>def fixGeometry(layer: QgsVectorLayer):\n    \"\"\"\n    Attempts to create a valid representation of a given invalid geometry without losing any of the input vertices.\n    Already valid geometries are returned without further intervention. Always outputs multi-geometry layer.\n    QGIS processing algorithem: native:fixgeometries\n\n    Parameters\n    ----------\n    layer : QgsVectorLayer [vector: any]\n        The QgsVectorLayer input for the algorithem\n\n\n    Returns\n    -------\n    QgsVectorLayer [vector: any]\n        The result output from the algorithem\n\n    \"\"\"\n    logger.info(\"Fixing geometries\")\n    if layerHasFeatures(layer):\n        logger.info(\"Processing \" + str(layer.featureCount()) +\" features\")\n    try:\n        parameter = {\n            'INPUT': layer,\n            'OUTPUT': 'memory:buffer'\n        }\n        logger.info(f'Parameters: {str(parameter)}')\n        result = processing.run('native:fixgeometries', parameter, feedback=Worker.progress)['OUTPUT']\n        logger.info(\"FixGeometry finished\")\n        return result\n    except Exception as error:\n        logger.error(\"An error occured in FixGeometry\")\n        logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n        logger.critical(\"Program terminated\" )\n        sys.exit()\n</code></pre>"},{"location":"workers/#python.engine.workers.Worker.Vector.forceRHR","title":"<code>forceRHR(layer)</code>","text":"<p>Forces polygon geometries to respect the Right-Hand-Rule, in which the area that is bounded by a polygon is to the right of the boundary.  In particular, the exterior ring is oriented in a clockwise direction and any interior rings in a counter-clockwise direction. QGIS processing algorithem: native:forcerhr</p>"},{"location":"workers/#python.engine.workers.Worker.Vector.forceRHR--parameters","title":"Parameters","text":"<p>layer : QgsVectorLayer [vector: polygon]     The QgsVectorLayer input for the algorithem</p>"},{"location":"workers/#python.engine.workers.Worker.Vector.forceRHR--returns","title":"Returns","text":"<p>QgsVectorLayer [vector: polygon]     The result output from the algorithem</p> Source code in <code>python\\engine\\workers.py</code> <pre><code>def forceRHR(layer: QgsVectorLayer):\n    \"\"\"\n    Forces polygon geometries to respect the Right-Hand-Rule, in which the area that is bounded\n    by a polygon is to the right of the boundary. \n    In particular, the exterior ring is oriented in a clockwise direction and any interior\n    rings in a counter-clockwise direction.\n    QGIS processing algorithem: native:forcerhr\n\n    Parameters\n    ----------\n    layer : QgsVectorLayer [vector: polygon]\n        The QgsVectorLayer input for the algorithem\n\n\n    Returns\n    -------\n    QgsVectorLayer [vector: polygon]\n        The result output from the algorithem\n    \"\"\"\n\n    logger.info(\"Running force right-hand rule\")\n    if layerHasFeatures(layer):\n        logger.info(\"Processing \" + str(layer.featureCount()) +\" features\")\n    try:\n        parameter = {\n            'INPUT': layer,\n            'OUTPUT': 'memory:forced'\n        }\n        result = processing.run('native:forcerhr', parameter, feedback=Worker.progress)['OUTPUT']\n        logger.info(\"forceRHR finished\")\n        return result\n    except Exception as error:\n        logger.error(\"An error occured in forceRHR\")\n        logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n        logger.critical(\"Program terminated\" )\n        sys.exit()\n</code></pre>"},{"location":"workers/#python.engine.workers.Worker.Vector.joinByLocation","title":"<code>joinByLocation(layer, predicate, join, join_fields, method, discard_nomatching, prefix)</code>","text":"<p>Takes an input vector layer and creates a new vector layer that is an extended version of the input one, with additional attributes in its attribute table. The additional attributes and their values are taken from a second vector layer. A spatial criteria is applied to select the values from the second layer that are added to each  feature from the first layer.</p>"},{"location":"workers/#python.engine.workers.Worker.Vector.joinByLocation--parameters","title":"Parameters","text":"<p>layer : QgsVectorLayer [vector: any]     Input vector layer.      The output layer will consist of the features of this layer with attributes from      matching features in the second layer.</p> [enumeration] Default: [0] <p>Type of spatial relation the source feature should have with the target feature so that they could be joined. One or more of: 0 \u2014 intersect, 1 \u2014 contain, 2 \u2014 equal, 3 \u2014 touch, 4 \u2014 overlap, 5 \u2014 are within 6 \u2014 cross.</p> [vector: any] <p>The join layer.  Features of this vector layer will add their attributes to the source layer attribute table if  they satisfy the spatial relationship.</p> tablefield: any <p>Select the specific fields you want to add from the join layer.  By default all the fields are added.</p> [enumeration] <p>The type of the final joined layer. One of:  0 \u2014 Create separate feature for each matching feature (one-to-many) 1 \u2014 Take attributes of the first matching feature only (one-to-one) 2 \u2014 Take attributes of the feature with largest overlap only (one-to-one)</p> [boolean] Default: False <p>Remove from the output the input layer\u2019s features which could not be joined</p> [string] <p>Add a prefix to joined fields in order to easily identify them and avoid field name collision</p>"},{"location":"workers/#python.engine.workers.Worker.Vector.joinByLocation--returns","title":"Returns","text":"<p>QgsVectorLayer [vector: any]     the output vector layer for the join.</p> Source code in <code>python\\engine\\workers.py</code> <pre><code>def joinByLocation(layer: QgsVectorLayer, predicate: int, join: str, join_fields: list, method: int, discard_nomatching: bool, prefix: str):\n    \"\"\"\n    Takes an input vector layer and creates a new vector layer that is an extended version of\n    the input one, with additional attributes in its attribute table.\n    The additional attributes and their values are taken from a second vector layer.\n    A spatial criteria is applied to select the values from the second layer that are added to each \n    feature from the first layer.\n\n    Parameters\n    ----------\n    layer : QgsVectorLayer [vector: any]\n        Input vector layer. \n        The output layer will consist of the features of this layer with attributes from \n        matching features in the second layer.\n\n    predicate : [enumeration] Default: [0]\n        Type of spatial relation the source feature should have with the target feature so that they could be joined. One or more of:\n        0 \u2014 intersect, 1 \u2014 contain, 2 \u2014 equal, 3 \u2014 touch, 4 \u2014 overlap, 5 \u2014 are within 6 \u2014 cross.\n\n    join : [vector: any]\n        The join layer. \n        Features of this vector layer will add their attributes to the source layer attribute table if \n        they satisfy the spatial relationship.\n\n    join_fields : [tablefield: any] [list]\n        Select the specific fields you want to add from the join layer. \n        By default all the fields are added.\n\n    method : [enumeration]           \t\n        The type of the final joined layer. One of: \n        0 \u2014 Create separate feature for each matching feature (one-to-many)\n        1 \u2014 Take attributes of the first matching feature only (one-to-one)\n        2 \u2014 Take attributes of the feature with largest overlap only (one-to-one)\n\n    discard_nomatching : [boolean] Default: False\n        Remove from the output the input layer\u2019s features which could not be joined\n\n    prefix : [string]\n        Add a prefix to joined fields in order to easily identify them and avoid field name collision\n\n    Returns\n    -------\n    QgsVectorLayer [vector: any]\n        the output vector layer for the join.\n    \"\"\"\n    logger.info(\"Clipping layers\")\n    try:\n        parameter = {\n            'INPUT': layer,\n            'PREDICATE':predicate,\n            'JOIN':join,\n            'JOIN_FIELDS':join_fields,\n            'METHOD':method,\n            'DISCARD_NONMATCHING':discard_nomatching,\n            'PREFIX':prefix,\n            'OUTPUT': 'memory:extracted'\n        }\n        logger.info(f'Parameters: {str(parameter)}')\n        result = processing.run('native:joinattributesbylocation', parameter, feedback=Worker.progress)['OUTPUT']\n        logger.info(\"joinByLocation finished\")\n        return result\n    except Exception as error:\n        logger.error(\"An error occured in joinByLocation\")\n        logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n        logger.critical(\"Program terminated\" )\n        sys.exit()\n</code></pre>"},{"location":"workers/#python.engine.workers.Worker.Vector.join_by_attribute","title":"<code>join_by_attribute(layer1, layer1_field, layer2, layer2_field, fields_to_copy, method, discard, prefix)</code>","text":"<p>Takes an input vector layer and creates a new vector layer that is an extended version of the input one,  with additional attributes in its attribute table. The additional attributes and their values are taken from a second vector layer. An attribute is selected in each of them  to define the join criteria. QGIS processing algorithem: native:joinattributestable.</p>"},{"location":"workers/#python.engine.workers.Worker.Vector.join_by_attribute--parameters","title":"Parameters","text":"<p>layer1 : QgsVectorLayer [vector: any]     The 1. QgsVectorLayer input for the algorithem</p> String <p>Field of the source layer to use for the join</p> QgsVectorLayer [vector: any] <p>The 2. QgsVectorLayer input for the algorithem</p> String <p>Field of the source layer to use for the join</p> List <p>Select the specific fields you want to add. By default all the fields are added. Default []</p> Integer <p>The type of the final joined layer. One of:  0 \u2014 Create separate feature for each matching feature (one-to-many) 1 \u2014 Take attributes of the first matching feature only (one-to-one)</p> Boolean <p>Check if you don\u2019t want to keep the features that could not be joined</p> String <p>Add a prefix to joined fields in order to easily identify them and avoid field name collision</p>"},{"location":"workers/#python.engine.workers.Worker.Vector.join_by_attribute--returns","title":"Returns","text":"<p>QgsVectorLayer [vector: polygon]     The result output from the algorithem</p> Source code in <code>python\\engine\\workers.py</code> <pre><code>def join_by_attribute(layer1: QgsVectorLayer, layer1_field:str, layer2: QgsVectorLayer, layer2_field: str, fields_to_copy: list, method:int, discard: bool, prefix:str):\n    \"\"\"\n    Takes an input vector layer and creates a new vector layer that is an extended version of the input one, \n    with additional attributes in its attribute table.\n    The additional attributes and their values are taken from a second vector layer. An attribute is selected in each of them \n    to define the join criteria.\n    QGIS processing algorithem: native:joinattributestable.\n\n    Parameters\n    ----------\n    layer1 : QgsVectorLayer [vector: any]\n        The 1. QgsVectorLayer input for the algorithem\n\n    layer1_field : String\n        Field of the source layer to use for the join\n\n    layer2 : QgsVectorLayer [vector: any]\n        The 2. QgsVectorLayer input for the algorithem\n\n    layer2_field : String\n        Field of the source layer to use for the join\n\n    fields_to_copy : List\n        Select the specific fields you want to add. By default all the fields are added. Default []\n\n    method : Integer\n        The type of the final joined layer. One of: \n        0 \u2014 Create separate feature for each matching feature (one-to-many)\n        1 \u2014 Take attributes of the first matching feature only (one-to-one)\n\n    discard : Boolean\n        Check if you don\u2019t want to keep the features that could not be joined\n\n    prefix : String\n        Add a prefix to joined fields in order to easily identify them and avoid field name collision\n\n    Returns\n    -------\n    QgsVectorLayer [vector: polygon]\n        The result output from the algorithem\n\n    \"\"\"\n    logger.info(\"Joining features features\")\n    if layerHasFeatures(layer1):\n        logger.info(\"Processing \" + str(layer1.featureCount()) +\" features\")\n    try:\n        parameter = {\n            'INPUT':layer1,\n            'FIELD':layer1_field,\n            'INPUT_2':layer2,\n            'FIELD_2':layer2_field,\n            'FIELDS_TO_COPY':fields_to_copy,\n            'METHOD':method,\n            'DISCARD_NONMATCHING':discard,\n            'PREFIX':prefix,\n            'OUTPUT': 'memory:joined'\n        }\n        logger.info(f'Parameters: {str(parameter)}')\n        result = processing.run('native:joinattributestable', parameter, feedback=Worker.progress)['OUTPUT']\n        logger.info(\"Joinattributestable finished\")\n        if layerHasFeatures(result):\n            logger.info(\"Returning \" + str(result.featureCount()) +\" features\")\n        return result\n    except Exception as error:\n        logger.error(\"An error occured in joinattributestable\")\n        logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n        logger.critical(\"Program terminated\" )\n        sys.exit()\n</code></pre>"},{"location":"workers/#python.engine.workers.Worker.Vector.kmeansclustering","title":"<code>kmeansclustering(inputlayer, clusters)</code>","text":"<p>Calculates the 2D distance based k-means cluster number for each input feature. K-means clustering aims to partition the features into k clusters in which each feature belongs to the cluster with the nearest mean. The mean point is represented by the barycenter of the clustered features. If input geometries are lines or polygons, the clustering is based on the centroid of the feature.</p>"},{"location":"workers/#python.engine.workers.Worker.Vector.kmeansclustering--parameters","title":"Parameters","text":"<p>inputlayer : QgsVectorLayer     Layer to analyze</p> int <p>Number of clusters to create with the features</p>"},{"location":"workers/#python.engine.workers.Worker.Vector.kmeansclustering--returns","title":"Returns","text":"<p>QgsVectorLayer     Specify the output vector layer for generated the clusters.</p> Source code in <code>python\\engine\\workers.py</code> <pre><code>def kmeansclustering(inputlayer: QgsVectorLayer, clusters: int):\n    \"\"\"\n    Calculates the 2D distance based k-means cluster number for each input feature.\n    K-means clustering aims to partition the features into k clusters in which each feature belongs to the cluster with the nearest mean. The mean point is represented by the barycenter of the clustered features.\n    If input geometries are lines or polygons, the clustering is based on the centroid of the feature.\n\n    Parameters\n    ----------\n    inputlayer : QgsVectorLayer\n        Layer to analyze\n\n    clusters : int\n        Number of clusters to create with the features\n\n    Returns\n    -------\n    QgsVectorLayer\n        Specify the output vector layer for generated the clusters.\n    \"\"\"\n\n    logger.info('Calculating clusters')\n    try:\n        parameters = {\n            'INPUT': inputlayer,\n            'CLUSTERS' : clusters,\n            'OUTPUT': 'memory:output_from_kmeansclustering'\n        }\n        logger.info(f'Parameters: {str(parameters)}')\n        result = processing.run('native:kmeansclustering', parameters, feedback=Worker.progress)['OUTPUT']\n        logger.info('Kmeansclustering finished')\n        return result\n    except Exception as error:\n        logger.error(\"An error occured in Kmeansclustering\")\n        logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n        logger.critical(\"Program terminated\" )\n        script_failed()\n</code></pre>"},{"location":"workers/#python.engine.workers.Worker.Vector.lineintersections","title":"<code>lineintersections(inputlayer, split_layer, input_fields, intersect_fields)</code>","text":"<p>Splits the lines or polygons in one layer using the lines or polygon rings in another layer to define the breaking points. Intersection between geometries in both layers are considered as split points. Output will contain multi geometries for split features.</p>"},{"location":"workers/#python.engine.workers.Worker.Vector.lineintersections--parameters","title":"Parameters","text":"<p>inputlayer : QgsVectorLayer     Input line layer.</p> QgsVectorLayer <p>Layer to use to find line intersections.</p> list <p>Field(s) of the input layer to keep in the output. If no fields are chosen all fields are taken.</p> list <p>Field(s) of the intersect layer to keep in the output. If no fields are chosen all fields are taken. Duplicate field names will be appended a count suffix to avoid collision</p>"},{"location":"workers/#python.engine.workers.Worker.Vector.lineintersections--returns","title":"Returns","text":"<p>QgsVectorLayer     Specify the layer to contain the intersection points of the lines from the input and overlay layers.</p> Source code in <code>python\\engine\\workers.py</code> <pre><code>def lineintersections(inputlayer: QgsVectorLayer, split_layer: QgsVectorLayer, input_fields: list, intersect_fields: list):\n    \"\"\"\n    Splits the lines or polygons in one layer using the lines or polygon rings in another layer to define the breaking points. Intersection between geometries in both layers are considered as split points.\n    Output will contain multi geometries for split features.\n\n    Parameters\n    ----------\n    inputlayer : QgsVectorLayer\n        Input line layer.\n\n    split_layer : QgsVectorLayer\n        Layer to use to find line intersections.\n\n    input_fields : list\n        Field(s) of the input layer to keep in the output. If no fields are chosen all fields are taken.\n\n    intersect_fields : list\n        Field(s) of the intersect layer to keep in the output. If no fields are chosen all fields are taken. Duplicate field names will be appended a count suffix to avoid collision\n\n    Returns\n    -------\n    QgsVectorLayer\n        Specify the layer to contain the intersection points of the lines from the input and overlay layers.\n\n    \"\"\"\n    logger.info('Performing line intersections')\n    try:\n        parameters = {\n            'INPUT': inputlayer,\n            'INTERSECT': split_layer,\n            'INPUT_FIELDS' : input_fields, \n            'INTERSECT_FIELDS' : intersect_fields,\n            'OUTPUT': 'memory:output_from_lineintersections'\n        }\n        logger.info(f'Parameters: {str(parameters)}')\n        result = processing.run('native:lineintersections', parameters, feedback=Worker.progress)['OUTPUT']\n        logger.info('Lineintersections finished')\n        return result\n    except Exception as error:\n        logger.error(\"An error occured in Lineintersections\")\n        logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n        logger.critical(\"Program terminated\" )\n        script_failed()\n</code></pre>"},{"location":"workers/#python.engine.workers.Worker.Vector.mergeVectorLayers","title":"<code>mergeVectorLayers(layers, crs)</code>","text":"<p>Combines multiple vector layers of the same geometry type into a single one. The attribute table of the resulting layer will contain the fields from all input layers.  If fields with the same name but different types are found then the exported field will be automatically  converted into a string type field. New fields storing the original layer name and source are also added.</p> <p>Optionally, the destination coordinate reference system (CRS) for the merged layer can be set. If it is  not set, the CRS will be taken from the first input layer. All layers will be reprojected to match this CRS.</p>"},{"location":"workers/#python.engine.workers.Worker.Vector.mergeVectorLayers--parameters","title":"Parameters","text":"<p>layer : List vector: any     The layers that are to be merged into a single layer. Layers should be of the same geometry type.</p> [crs] <p>Choose the CRS for the output layer. If not specified, the CRS of the first input layer is used.</p>"},{"location":"workers/#python.engine.workers.Worker.Vector.mergeVectorLayers--returns","title":"Returns","text":"<p>QgsVectorLayer [vector: any]     The result output from the algorithem</p> Source code in <code>python\\engine\\workers.py</code> <pre><code>def mergeVectorLayers(layers: list, crs: str ):\n    \"\"\"\n    Combines multiple vector layers of the same geometry type into a single one.\n    The attribute table of the resulting layer will contain the fields from all input layers. \n    If fields with the same name but different types are found then the exported field will be automatically \n    converted into a string type field. New fields storing the original layer name and source are also added.\n\n    Optionally, the destination coordinate reference system (CRS) for the merged layer can be set. If it is \n    not set, the CRS will be taken from the first input layer. All layers will be reprojected to match this CRS.\n\n    Parameters\n    ----------\n    layer : List [vector: any] [list]\n        The layers that are to be merged into a single layer. Layers should be of the same geometry type.\n\n    CRS : [crs]\n        Choose the CRS for the output layer. If not specified, the CRS of the first input layer is used.\n\n    Returns\n    -------\n    QgsVectorLayer [vector: any]\n        The result output from the algorithem\n\n    \"\"\"\n    logger.info(\"Performing mergeVectorLayers\")\n    logger.info(f'Processing {str(len(layers))} layers')\n    try:\n        parameter = {\n            'LAYERS': layers,\n            'CRS':crs,\n            'OUTPUT': 'memory:buffer'\n        }\n        logger.info(f'Parameters: {str(parameter)}')\n        result = processing.run('native:mergevectorlayers', parameter, feedback=Worker.progress)['OUTPUT']\n        logger.info(\"Returning \" + str(result.featureCount()) +\" features\")\n        logger.info(\"mergeVectorLayers finished\")\n        return result\n    except Exception as error:\n        logger.error(\"An error occured in mergeVectorLayers\")\n        logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n        logger.critical(\"Program terminated\" )\n        script_failed()\n</code></pre>"},{"location":"workers/#python.engine.workers.Worker.Vector.multiringconstantbuffer","title":"<code>multiringconstantbuffer(inputlayer, rings, distance)</code>","text":"<p>Computes multi-ring (donut) buffer for the features of the input layer, using a fixed or dynamic distance and number of rings.</p>"},{"location":"workers/#python.engine.workers.Worker.Vector.multiringconstantbuffer--parameters","title":"Parameters","text":"<p>inputlayer : QgsVectorLayer     Input vector layer</p> int <p>The number of rings. It can be a unique value (same number of rings for all the features) or it can be taken from features data (the number of rings depends on feature values).</p> str <p>Distance between the rings. It can be a unique value (same distance for all the features) or it can be taken from features data (a field in the input data layer).</p>"},{"location":"workers/#python.engine.workers.Worker.Vector.multiringconstantbuffer--returns","title":"Returns","text":"<p>QgsVectorLayer [polygon]     Specify the output polygon vector layer</p> Source code in <code>python\\engine\\workers.py</code> <pre><code>def multiringconstantbuffer(inputlayer:QgsVectorLayer, rings: int, distance : str):\n    \"\"\"\n    Computes multi-ring (donut) buffer for the features of the input layer, using a fixed or dynamic distance and number of rings.\n\n    Parameters\n    ----------\n    inputlayer : QgsVectorLayer\n        Input vector layer\n\n    rings : int\n        The number of rings. It can be a unique value (same number of rings for all the features) or it can be taken from features data (the number of rings depends on feature values).\n\n    distance : str\n        Distance between the rings. It can be a unique value (same distance for all the features) or it can be taken from features data (a field in the input data layer).\n\n    Returns\n    -------\n    QgsVectorLayer [polygon]\n        Specify the output polygon vector layer\n\n    \"\"\"\n    logger.info('Creating multiringconstantbuffer')\n    try:\n        dist = float(distance)\n        logger.info('Using distance value')\n    except:\n        dist = QgsProperty.fromExpression(f'\"{distance}\"')\n        logger.info('Using distance from field')\n\n    try:\n        parameters = {\n            'INPUT': inputlayer,\n            'RINGS': rings,\n            'DISTANCE': distance,\n            'OUTPUT': 'memory:output_from_multiringconstantbuffer'\n        }\n        logger.info(f'Parameters: {str(parameters)}')\n        result = processing.run('native:multiringconstantbuffer', parameters, feedback=Worker.progress)['OUTPUT']\n        logger.info('multiringconstantbuffer finished')\n        return result\n    except Exception as error:\n        logger.error(\"An error occured in multiringconstantbuffer\")\n        logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n        logger.critical(\"Program terminated\" )\n        script_failed() \n</code></pre>"},{"location":"workers/#python.engine.workers.Worker.Vector.poleofinaccessibility","title":"<code>poleofinaccessibility(inputlayer, tolerance)</code>","text":"<p>Calculates the pole of inaccessibility for a polygon layer, which is the most distant internal point from the boundary of the surface.  This algorithm uses the \u2018polylabel\u2019 algorithm (Vladimir Agafonkin, 2016), which is an iterative approach guaranteed to find the true pole of inaccessibility within a specified tolerance. A more precise tolerance (lower value) requires more iterations and will take longer to calculate.  The distance from the calculated pole to the polygon boundary will be stored as a new attribute in the output layer.</p>"},{"location":"workers/#python.engine.workers.Worker.Vector.poleofinaccessibility--parameters","title":"Parameters","text":"<p>inputlayer : QgsVectorLayer [polygon]     Input vector layer</p> int <p>Set the tolerance for the calculation. Default 1</p>"},{"location":"workers/#python.engine.workers.Worker.Vector.poleofinaccessibility--returns","title":"Returns","text":"<p>QgsVectorLayer [point]     Specify the output polygon vector layer.</p> Source code in <code>python\\engine\\workers.py</code> <pre><code>def poleofinaccessibility(inputlayer:QgsVectorLayer, tolerance: int):\n    \"\"\"\n    Calculates the pole of inaccessibility for a polygon layer, which is the most distant internal point from the boundary of the surface. \n    This algorithm uses the \u2018polylabel\u2019 algorithm (Vladimir Agafonkin, 2016), which is an iterative approach guaranteed to find the true pole of inaccessibility within\n    a specified tolerance. A more precise tolerance (lower value) requires more iterations and will take longer to calculate. \n    The distance from the calculated pole to the polygon boundary will be stored as a new attribute in the output layer.\n\n    Parameters\n    ----------\n    inputlayer : QgsVectorLayer [polygon]\n        Input vector layer\n\n    tolerance : int\n        Set the tolerance for the calculation. Default 1\n\n    Returns\n    -------\n    QgsVectorLayer [point]\n        Specify the output polygon vector layer.\n    \"\"\"\n    logger.info('calcualting poleofinaccessibility')\n    try:\n        parameters = {\n            'INPUT': inputlayer,\n            'TOLERANCE' : tolerance,\n            'OUTPUT': 'memory:output_from_poleofinaccessibility'\n        }\n        logger.info(f'Parameters: {str(parameters)}')\n        result = processing.run('native:poleofinaccessibility', parameters, feedback=Worker.progress)['OUTPUT']\n        logger.info('poleofinaccessibility finished')\n        return result\n    except Exception as error:\n        logger.error(\"An error occured in poleofinaccessibility\")\n        logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n        logger.critical(\"Program terminated\" )\n        script_failed()\n</code></pre>"},{"location":"workers/#python.engine.workers.Worker.Vector.promoteToMultipart","title":"<code>promoteToMultipart(layer)</code>","text":"<p>Generates a vectorlayer in which all geometries are multipart.</p>"},{"location":"workers/#python.engine.workers.Worker.Vector.promoteToMultipart--parameters","title":"Parameters","text":"<p>layer : QgsVectorLayer     The QgsVectorLayer that is used as input.</p>"},{"location":"workers/#python.engine.workers.Worker.Vector.promoteToMultipart--returns","title":"Returns","text":"<p>QgsVectorLayer     The QgsVectorLayer containing multi geometries.</p> Source code in <code>python\\engine\\workers.py</code> <pre><code>def promoteToMultipart(layer: QgsVectorLayer):\n    \"\"\"\n    Generates a vectorlayer in which all geometries are multipart.\n\n    Parameters\n    ----------\n    layer : QgsVectorLayer\n        The QgsVectorLayer that is used as input.\n\n    Returns\n    -------\n    QgsVectorLayer\n        The QgsVectorLayer containing multi geometries.\n    \"\"\"\n\n    logger.info('Collecting geometries')\n    try:\n        parameters = {\n            'INPUT': layer,\n            'OUTPUT': 'memory:multipart'\n        }\n        logger.info(f'Parameters: {str(parameters)}')\n        result = processing.run('native:promotetomulti', parameters, feedback=Worker.progress)['OUTPUT']\n        logger.info('Promote to multipart finished')\n        return result\n    except Exception as error:\n        logger.error(\"An error occured in promoteToMultipart\")\n        logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n        logger.critical(\"Program terminated\" )\n        script_failed()\n</code></pre>"},{"location":"workers/#python.engine.workers.Worker.Vector.randomExtract","title":"<code>randomExtract(layer, method, number)</code>","text":"<p>Takes a vector layer and generates a new one that contains only a subset of the features in the input layer. The subset is defined randomly, based on feature IDs, using a percentage or count value to define  the total number of features in the subset.</p>"},{"location":"workers/#python.engine.workers.Worker.Vector.randomExtract--parameters","title":"Parameters","text":"<p>layer : QgsVectorLayer [vector: any]     Input vector layer. </p> [enumeration] Default: 0 <p>Random selection method. One of: 0 \u2014 Number of selected features 1 \u2014 Percentage of selected features</p> [number] Default: 10 <p>Number or percentage of features to select</p>"},{"location":"workers/#python.engine.workers.Worker.Vector.randomExtract--returns","title":"Returns","text":"<p>QgsVectorLayer [vector: polygon/line]     The result output from the algorithem</p> Source code in <code>python\\engine\\workers.py</code> <pre><code>def randomExtract(layer: QgsVectorLayer, method: int, number: int):\n    \"\"\"\n    Takes a vector layer and generates a new one that contains only a subset of the features in the input layer.\n    The subset is defined randomly, based on feature IDs, using a percentage or count value to define \n    the total number of features in the subset.\n\n    Parameters\n    ----------\n    layer : QgsVectorLayer [vector: any]\n        Input vector layer. \n\n    method : [enumeration] Default: 0\n        Random selection method. One of: 0 \u2014 Number of selected features 1 \u2014 Percentage of selected features\n\n    number : [number] Default: 10\n        Number or percentage of features to select\n\n    Returns\n    -------\n    QgsVectorLayer [vector: polygon/line]\n        The result output from the algorithem\n    \"\"\"\n    logger.info(\"Extracting random features\")\n    try:\n        parameter = {\n            'INPUT': layer,\n            'METHOD':method,\n            'NUMBER':number,\n            'OUTPUT': 'memory:extracted'\n        }\n        logger.info(f'Parameters: {str(parameter)}')\n        result = processing.run('native:randomextract', parameter, feedback=Worker.progress)['OUTPUT']\n        logger.info(\"randomExtract finished\")\n        return result\n    except Exception as error:\n        logger.error(\"An error occured in randomExtract\")\n        logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n        logger.critical(\"Program terminated\" )\n        sys.exit()\n</code></pre>"},{"location":"workers/#python.engine.workers.Worker.Vector.randomselection","title":"<code>randomselection(layer, method, number)</code>","text":"<p>Takes a vector layer and selects a subset of its features. No new layer is generated by this algorithm. The subset is defined randomly, based on feature IDs, using a percentage or count value to define the  total number of features in the subset.</p>"},{"location":"workers/#python.engine.workers.Worker.Vector.randomselection--parameters","title":"Parameters","text":"<p>layer : QgsVectorLayer [vector: any]     The QgsVectorLayer input for the algorithem</p> Integer <p>Random selection method. One of: 0 \u2014 Number of selected features, 1 \u2014 Percentage of selected features</p> Integer <p>Number or percentage of features to select</p>"},{"location":"workers/#python.engine.workers.Worker.Vector.randomselection--returns","title":"Returns","text":"<p>QgsVectorLayer [vector: any]     The result output from the algorithem</p> Source code in <code>python\\engine\\workers.py</code> <pre><code>def randomselection(layer: QgsVectorLayer, method: int, number: int):\n    \"\"\"\n    Takes a vector layer and selects a subset of its features. No new layer is generated by this algorithm.\n    The subset is defined randomly, based on feature IDs, using a percentage or count value to define the \n    total number of features in the subset.\n\n    Parameters\n    ----------\n    layer : QgsVectorLayer [vector: any]\n        The QgsVectorLayer input for the algorithem\n\n    method : Integer\n        Random selection method. One of: 0 \u2014 Number of selected features, 1 \u2014 Percentage of selected features\n\n    number : Integer\n        Number or percentage of features to select\n\n    Returns\n    -------\n    QgsVectorLayer [vector: any]\n        The result output from the algorithem\n    \"\"\"\n    logger.info(\"Performing random selection\")\n    if layerHasFeatures(layer):\n        logger.info(\"Processing \" + str(layer.featureCount()) +\" features\")\n    try:\n        parameter = {\n            'INPUT': layer,\n            'METHOD':method,\n            'NUMBER':number,\n            'OUTPUT': 'memory:buffer'\n        }\n        logger.info(f'Parameters: {str(parameter)}')\n        result = processing.run('native:randomextract', parameter, feedback=Worker.progress)['OUTPUT']\n        if layerHasFeatures(result):\n            logger.info(\"Returning \" + str(result.featureCount()) +\" features\")\n        logger.info(\"randomextract finished\")\n        return result\n    except Exception as error:\n        logger.error(\"An error occured in FixGeometry\")\n        logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n        logger.critical(\"Program terminated\" )\n        sys.exit()\n</code></pre>"},{"location":"workers/#python.engine.workers.Worker.Vector.renameTableField","title":"<code>renameTableField(layer, field, newname)</code>","text":"<p>Renames an existing field from a vector layer. The original layer is not modified. A new layer is generated where the attribute table contains the renamed field. QGIS processing algorithem: native:renametablefield</p>"},{"location":"workers/#python.engine.workers.Worker.Vector.renameTableField--parameters","title":"Parameters","text":"<p>layer : QgsVectorLayer [vector: any]     The QgsVectorLayer input for the algorithem</p> Tablefield <p>The field that is to be renamed</p> String <p>New name for the field</p>"},{"location":"workers/#python.engine.workers.Worker.Vector.renameTableField--returns","title":"Returns","text":"<p>QgsVectorLayer [vector: any]     The result output from the algorithem</p> Source code in <code>python\\engine\\workers.py</code> <pre><code>def renameTableField (layer: QgsVectorLayer, field: str, newname: str):\n    \"\"\"\n    Renames an existing field from a vector layer.  \n    The original layer is not modified. A new layer is generated where the attribute table contains the renamed field.\n    QGIS processing algorithem: native:renametablefield\n\n    Parameters\n    ----------\n    layer : QgsVectorLayer [vector: any]\n        The QgsVectorLayer input for the algorithem\n\n    field : Tablefield\n        The field that is to be renamed\n\n    newname : String\n        New name for the field\n\n\n    Returns\n    -------\n    QgsVectorLayer [vector: any]\n        The result output from the algorithem\n    \"\"\"\n    logger.info(\"Renaming field\")\n    try:\n        parameter = {\n            'INPUT': layer,\n            'FIELD': field,\n            'NEW_NAME': newname,\n            'OUTPUT': 'memory:extracted'\n        }\n        result = processing.run('native:renametablefield', parameter, feedback=Worker.progress)['OUTPUT']\n        logger.info(f'Parameters: {str(parameter)}')\n        logger.info(\"renameTableField  finished\")\n        return result\n    except Exception as error:\n        logger.error(\"An error occured in renameTableField\")\n        logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n        logger.critical(\"Program terminated\" )\n        sys.exit()\n</code></pre>"},{"location":"workers/#python.engine.workers.Worker.Vector.reproject","title":"<code>reproject(layer, targetEPSG)</code>","text":"<p>Reprojects a vector layer in a different CRS. The reprojected layer will have the same features and attributes of the input layer. QGIS processing algorithem: native:reprojectlayer.</p>"},{"location":"workers/#python.engine.workers.Worker.Vector.reproject--parameters","title":"Parameters","text":"<p>layer : QgsVectorLayer [vector: polygon]     The QgsVectorLayer input for the algorithem</p> Integer <p>The EPSG code og the target coordinate system.</p>"},{"location":"workers/#python.engine.workers.Worker.Vector.reproject--returns","title":"Returns","text":"<p>QgsVectorLayer [vector: polygon]     The result output from the algorithem</p> Source code in <code>python\\engine\\workers.py</code> <pre><code>def reproject(layer: QgsVectorLayer, targetEPSG: int):\n    \"\"\"\n    Reprojects a vector layer in a different CRS.\n    The reprojected layer will have the same features and attributes of the input layer.\n    QGIS processing algorithem: native:reprojectlayer.\n\n    Parameters\n    ----------\n    layer : QgsVectorLayer [vector: polygon]\n        The QgsVectorLayer input for the algorithem\n\n    targetEPSG : Integer\n        The EPSG code og the target coordinate system.\n\n\n    Returns\n    -------\n    QgsVectorLayer [vector: polygon]\n        The result output from the algorithem\n    \"\"\"\n\n    logger.info(\"Running reporjector V2\")\n    if layerHasFeatures(layer):\n        logger.info(\"Processing \" + str(layer.featureCount()) +\" features\")\n    try:\n        parameter = {\n            'INPUT': layer,\n            'TARGET_CRS': QgsCoordinateReferenceSystem(targetEPSG),\n            'OUTPUT': 'memory:Reprojected'\n        }\n        logger.info(f'Parameters: {str(parameter)}')\n        result = processing.run('native:reprojectlayer', parameter, feedback=Worker.progress)['OUTPUT']\n        logger.info(\"Reproject finished\")\n        return result\n    except Exception as error:\n        logger.error(\"An error occured reprojectiong layer\")\n        logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n        logger.critical(\"Program terminated\" )\n        sys.exit()\n</code></pre>"},{"location":"workers/#python.engine.workers.Worker.Vector.simplify","title":"<code>simplify(layer, method, tolerance)</code>","text":"<p>Simplifies the geometries in a line or polygon layer.  It creates a new layer with the same features as the ones in the input layer, but with geometries containing a lower number of vertices. QGIS processing algorithem: native:simplifygeometries.</p>"},{"location":"workers/#python.engine.workers.Worker.Vector.simplify--parameters","title":"Parameters","text":"<p>layer : QgsVectorLayer [vector: polygon]     The QgsVectorLayer input for the algorithem</p> Integer <p>Simplification method. One of: 0 \u2014 Distance (Douglas-Peucker), 1 \u2014 Snap to grid, 2 \u2014 Area (Visvalingam)</p> Integer <p>Threshold tolerance (in units of the layer): if the distance between two nodes is smaller than the tolerance value, the segment will be simplified and vertices will be removed.</p>"},{"location":"workers/#python.engine.workers.Worker.Vector.simplify--returns","title":"Returns","text":"<p>QgsVectorLayer [vector: polygon/line]     The result output from the algorithem</p> Source code in <code>python\\engine\\workers.py</code> <pre><code>def simplify(layer: QgsVectorLayer, method: int, tolerance:int):\n        \"\"\"\n        Simplifies the geometries in a line or polygon layer. \n        It creates a new layer with the same features as the ones in the input layer, but with geometries containing a lower number of vertices.\n        QGIS processing algorithem: native:simplifygeometries.\n\n        Parameters\n        ----------\n        layer : QgsVectorLayer [vector: polygon]\n            The QgsVectorLayer input for the algorithem\n\n        method : Integer\n            Simplification method. One of: 0 \u2014 Distance (Douglas-Peucker), 1 \u2014 Snap to grid, 2 \u2014 Area (Visvalingam)\n\n        tolerance : Integer\n            Threshold tolerance (in units of the layer): if the distance between two nodes is smaller than the tolerance value,\n            the segment will be simplified and vertices will be removed.\n\n\n        Returns\n        -------\n        QgsVectorLayer [vector: polygon/line]\n            The result output from the algorithem\n        \"\"\"\n\n        logger.info(\"Running simplify\")\n        if layerHasFeatures(layer):\n            logger.info(\"Processing \" + str(layer.featureCount()) +\" features\")\n        try:\n            parameter = {\n                'INPUT': layer,\n                'METHOD':method,\n                'TOLERANCE':tolerance,\n                'OUTPUT': 'memory:simplify'\n            }\n            logger.info(f'Parameters: {str(parameter)}')\n            result = processing.run('native:simplifygeometries', parameter, feedback=Worker.progress)['OUTPUT']\n            logger.info(\"Simplifygeometries finished\")\n            return result\n        except Exception as error:\n            logger.error(\"An error occured in simplifygeometries\")\n            logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n            logger.critical(\"Program terminated\" )\n            sys.exit()\n</code></pre>"},{"location":"workers/#python.engine.workers.Worker.Vector.spatialindex","title":"<code>spatialindex(layer)</code>","text":"<p>Creates an index to speed up access to the features in a layer based on their spatial location. Support for spatial index creation is dependent on the layer's data provider.</p>"},{"location":"workers/#python.engine.workers.Worker.Vector.spatialindex--parameters","title":"Parameters","text":"<p>layer : QgsVectorLayer [vector: any]     The QgsVectorLayer input for the algorithem</p>"},{"location":"workers/#python.engine.workers.Worker.Vector.spatialindex--returns","title":"Returns","text":"<p>QgsVectorLayer [vector: any]     The result output from the algorithem</p> Source code in <code>python\\engine\\workers.py</code> <pre><code>def spatialindex(layer: QgsVectorLayer):\n    \"\"\"\n    Creates an index to speed up access to the features in a layer based on their spatial location.\n    Support for spatial index creation is dependent on the layer's data provider.\n\n    Parameters\n    ----------\n    layer : QgsVectorLayer [vector: any]\n        The QgsVectorLayer input for the algorithem\n\n    Returns\n    -------\n    QgsVectorLayer [vector: any]\n        The result output from the algorithem\n    \"\"\"\n\n    logger.info(\"Crating spatial index on \" + layer)\n    try:\n        parameter = {\n            'INPUT': layer,\n            'OUTPUT': 'memory:extracted'\n        }\n        result = processing.run('native:createspatialindex', parameter, feedback=Worker.progress)['OUTPUT']\n        logger.info(f'Parameters: {str(parameter)}')\n        logger.info(\"createspatialindex  finished\")\n        return result\n    except Exception as error:\n        logger.error(\"An error occured in createspatialindex\")\n        logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n        logger.critical(\"Program terminated\" )\n        sys.exit()\n</code></pre>"},{"location":"workers/#python.engine.workers.Worker.Vector.symmetricaldifference","title":"<code>symmetricaldifference(inputlayer, overlay_layer)</code>","text":"<p>Creates a layer containing features from both the input and overlay layers but with the overlapping areas between the two layers removed. The attribute table of the symmetrical difference layer contains attributes and fields from both the input and overlay layers.</p>"},{"location":"workers/#python.engine.workers.Worker.Vector.symmetricaldifference--parameters","title":"Parameters","text":"<p>inputlayer : QgsVectorLayer     First layer to extract (parts of) features from.</p> QgsVectorLayer <p>Second layer to extract (parts of) features from. Ideally the geometry type should be the same as input layer.</p>"},{"location":"workers/#python.engine.workers.Worker.Vector.symmetricaldifference--returns","title":"Returns","text":"<p>QgsVectorLayer     Specify the layer to contain (the parts of) the features from the input and overlay layers that do not overlap features from the other layer</p> Source code in <code>python\\engine\\workers.py</code> <pre><code>def symmetricaldifference(inputlayer: QgsVectorLayer, overlay_layer: QgsVectorLayer):\n    \"\"\"\n    Creates a layer containing features from both the input and overlay layers but with the overlapping areas between the two layers removed.\n    The attribute table of the symmetrical difference layer contains attributes and fields from both the input and overlay layers.\n\n    Parameters\n    ----------\n    inputlayer : QgsVectorLayer\n        First layer to extract (parts of) features from.\n\n    overlay_layer : QgsVectorLayer\n        Second layer to extract (parts of) features from. Ideally the geometry type should be the same as input layer.\n\n    Returns\n    -------\n    QgsVectorLayer\n        Specify the layer to contain (the parts of) the features from the input and overlay layers that do not overlap features from the other layer\n    \"\"\"\n\n    logger.info('calcualting symetrical difference')\n    try:\n        parameters = {\n            'INPUT': inputlayer,\n            'OVERLAY' : overlay_layer,\n            'OUTPUT': 'memory:output_from_symmetricaldifference'\n        }\n        logger.info(f'Parameters: {str(parameters)}')\n        result = processing.run('native:symmetricaldifference', parameters, feedback=Worker.progress)['OUTPUT']\n        logger.info('Symmetricaldifference finished')\n        return result\n    except Exception as error:\n        logger.error(\"An error occured in symmetricaldifference\")\n        logger.error(f'{type(error).__name__}  \u2013  {str(error)}')\n        logger.critical(\"Program terminated\" )\n        script_failed()\n</code></pre>"},{"location":"workers/#python.engine.workers.Worker.Vector.timeStamper","title":"<code>timeStamper(layer, ts_fieldname)</code>","text":"<pre><code>Create an attribute woth current timestamp on features.\n</code></pre>"},{"location":"workers/#python.engine.workers.Worker.Vector.timeStamper--parameters","title":"Parameters","text":"<p>layer : QgsVectorLayer [vector: any]     The QgsVectorLayer input for the algorithem</p> String <p>The name of the new timestamp field</p>"},{"location":"workers/#python.engine.workers.Worker.Vector.timeStamper--returns","title":"Returns","text":"<p>QgsVectorLayer [vector: any]     The result output from the algorithem</p> Source code in <code>python\\engine\\workers.py</code> <pre><code>def timeStamper(layer: QgsVectorLayer, ts_fieldname: str):\n    \"\"\"\n        Create an attribute woth current timestamp on features.\n\n    Parameters\n    ----------\n    layer : QgsVectorLayer [vector: any]\n        The QgsVectorLayer input for the algorithem\n\n    ts_fieldname : String\n        The name of the new timestamp field\n\n    Returns\n    -------\n    QgsVectorLayer [vector: any]\n        The result output from the algorithem\n    \"\"\"\n    logger.info(f'Creating timestamp {ts_fieldname} using fieldCalculator')\n    newLayer = Worker.fieldCalculator(layer, ts_fieldname, 5, 0, 0, ' now() ')\n    return newLayer\n</code></pre>"}]}